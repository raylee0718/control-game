<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æƒ¡é­”çš„è©›å’’ v1.0</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&family=Cinzel:wght@700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #121013;
            --surface-color: #1a1a1d;
            --primary-color: #c9a44e; /* Gold */
            --secondary-color: #a45ee5; /* Purple */
            --text-color: #e0e0e0;
            --text-muted-color: #888;
            --danger-color: #c74242; /* Crimson Red */
            --success-color: #82c97c;
            --font-body: 'Noto Sans TC', sans-serif;
            --font-display: 'Cinzel', serif;
        }

        @keyframes pulse-gold {
            0% { text-shadow: 0 0 10px var(--primary-color), 0 0 20px var(--primary-color); }
            50% { text-shadow: 0 0 20px var(--primary-color), 0 0 30px var(--primary-color); }
            100% { text-shadow: 0 0 10px var(--primary-color), 0 0 20px var(--primary-color); }
        }

        body {
            font-family: var(--font-body);
            background-color: var(--bg-color);
            background-image: radial-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 20px 20px;
            color: var(--text-color);
            margin: 0;
            padding: 1rem;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }

        .container {
            width: 100%;
            max-width: 900px;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .header {
            text-align: center;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 1rem;
        }

        .header h1 {
            font-family: var(--font-display);
            margin: 0;
            font-size: 3rem;
            color: var(--primary-color);
            text-shadow: 0 0 15px var(--primary-color);
        }

        .timer-display {
            font-family: var(--font-display);
            font-size: 4.5rem;
            font-weight: 700;
            text-align: center;
            color: var(--primary-color);
            background-color: var(--surface-color);
            padding: 1rem;
            border-radius: 1rem;
            border: 1px solid var(--primary-color);
            box-shadow: 0 0 20px rgba(201, 164, 78, 0.2);
            letter-spacing: 0.1em;
            animation: pulse-gold 3s infinite;
        }
        
        #buff-area {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: center;
        }
        
        .buff-item {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            width: 80%;
            max-width: 500px;
            text-align: left;
        }
        .buff-item.buff { background-color: rgba(130, 201, 124, 0.1); border: 1px solid var(--success-color); }
        .buff-item.debuff { background-color: rgba(199, 66, 66, 0.1); border: 1px solid var(--danger-color); }

        .buff-header { font-weight: bold; font-size: 0.9rem; }
        .buff-header.buff { color: var(--success-color); }
        .buff-header.debuff { color: var(--danger-color); }
        .buff-description { font-size: 0.8rem; color: var(--text-color); }

        #punishmentArea, #timersArea { display: flex; flex-direction: column; gap: 0.5rem; }
        .status-item { border-radius: 0.5rem; padding: 0.75rem 1rem; display: flex; justify-content: space-between; align-items: center; font-size: 0.9rem; }
        .status-item span { font-weight: bold; }
        .timer-item { background-color: rgba(201, 164, 78, 0.1); border: 1px solid var(--primary-color); }
        .timer-item span { color: var(--primary-color); }
        .punishment-item { background-color: rgba(199, 66, 66, 0.15); border: 1px solid var(--danger-color); }
        .punishment-item span { color: var(--danger-color); }

        .controls-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 1.5rem; }
        
        .control-card {
            background-color: var(--surface-color);
            border-radius: 1rem;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            border: 1px solid #333;
            transition: all 0.3s ease;
        }
        .control-card:hover { border-color: var(--primary-color); }

        .control-card h3 { font-family: var(--font-display); margin: 0 0 0.5rem 0; font-size: 1.7rem; color: var(--primary-color); text-align: center; }
        .control-card .charge-info { font-size: 0.8rem; color: var(--text-muted-color); background-color: #111; padding: 0.2rem 0.5rem; border-radius: 0.5rem; }
        .control-card .charge-cooldown { font-size: 0.8rem; color: var(--text-muted-color); margin: 0.5rem 0 0 0; }
        .control-card .description { margin: 0.5rem 0; font-size: 0.9rem; color: var(--text-muted-color); text-align: center; min-height: 2.7em; }
        .charge-count-display { font-size: 0.9rem; color: var(--secondary-color); margin-top: 0.5rem; font-weight: bold; }

        .btn { font-family: var(--font-display); padding: 0.75rem 1.5rem; font-size: 1.1rem; font-weight: 700; border: 1px solid var(--primary-color); border-radius: 0.5rem; cursor: pointer; transition: all 0.3s ease; width: 100%; display: flex; justify-content: center; align-items: center; gap: 0.5rem; background: transparent; color: var(--primary-color); }
        .btn:hover:not(:disabled) { background-color: var(--primary-color); color: var(--bg-color); box-shadow: 0 0 15px var(--primary-color); }
        .btn-danger { border-color: var(--danger-color); color: var(--danger-color); }
        .btn-danger:hover:not(:disabled) { background-color: var(--danger-color); color: white; box-shadow: 0 0 15px var(--danger-color); }
        .btn:disabled { border-color: #444; color: #666; cursor: not-allowed; }
        
        .dice-area { display: flex; gap: 2rem; margin-top: 0.5rem; padding: 1rem; background-color: #111; border-radius: 0.5rem; }
        .dice-container { display: flex; flex-direction: column; align-items: center; gap: 0.5rem; }
        .dice-label { font-size: 1rem; font-weight: 500; color: var(--text-muted-color); }
        .dice { width: 60px; height: 60px; background-color: #fff; border-radius: 10px; display: flex; justify-content: center; align-items: center; color: var(--bg-color); font-weight: bold; box-shadow: 0 2px 5px rgba(0,0,0,0.2); font-size: 3rem; }

        .slot-machine-container { width: 100%; max-width: 300px; height: 80px; background: #111; border-radius: 10px; overflow: hidden; position: relative; border: 3px solid var(--primary-color); box-shadow: inset 0 0 10px rgba(0,0,0,0.5); margin: 0.5rem 0; }
        .slot-reels { position: absolute; top: 0; left: 0; right: 0; transition: top 4s cubic-bezier(0.25, 1, 0.5, 1); }
        .slot-item { height: 80px; display: flex; justify-content: center; align-items: center; font-size: 1.5rem; font-weight: bold; }
        .slot-item.reward { color: var(--success-color); }
        .slot-item.penalty { color: var(--danger-color); }
        .slot-item.special { color: var(--secondary-color); }

        .log-section { background-color: var(--surface-color); border-radius: 1rem; padding: 1rem; border: 1px solid #333; }
        .log-section h3 { font-family: var(--font-display); margin-top: 0; color: var(--primary-color); border-bottom: 1px solid var(--text-muted-color); padding-bottom: 0.5rem; }
        #eventLog { height: 250px; overflow-y: auto; padding-right: 10px; }
        #eventLog p { margin: 0.5rem 0; font-size: 0.875rem; border-bottom: 1px solid #444; padding-bottom: 0.5rem; }
        #eventLog p:last-child { border-bottom: none; }
        
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.85); display: none; justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background-color: var(--surface-color); padding: 1.5rem 2rem; border-radius: 1rem; text-align: center; width: 95%; max-width: 700px; box-shadow: 0 5px 25px rgba(0,0,0,0.5); display: flex; flex-direction: column; gap: 1.5rem; border: 1px solid var(--primary-color); }
        .modal-content h2 { font-family: var(--font-display); color: var(--primary-color); }
        
        /* Roulette Styles */
        .roulette-container { position: relative; width: 300px; height: 300px; margin: 1rem auto; }
        #rouletteWheel { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 50%; border: 5px solid var(--primary-color); transition: transform 6s cubic-bezier(0.2, 0.8, 0.2, 1); transform-style: preserve-3d; }
        #rouletteWheel::before { content: ''; position: absolute; width: 90%; height: 90%; top: 5%; left: 5%; background: #333; border-radius: 50%; }
        .roulette-slice-text { position: absolute; top: 50%; left: 50%; width: 50%; height: 50%; transform-origin: 0 0; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.9rem; }
        #roulettePointer { position: absolute; top: -25px; left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 15px solid transparent; border-right: 15px solid transparent; border-top: 25px solid var(--primary-color); }
        #rouletteCurrentBet { font-weight: bold; color: var(--secondary-color); min-height: 1.2em; }

        /* Three Doors Styles */
        #threeDoorsContainer { display: flex; justify-content: space-around; gap: 1rem; margin: 1rem 0; }
        .door { width: 120px; height: 180px; border: 3px solid var(--primary-color); border-radius: 10px; background: linear-gradient(145deg, #4a2c0f, #2a1a09); cursor: pointer; transition: all 0.3s ease; display: flex; justify-content: center; align-items: center; font-size: 4rem; color: var(--primary-color); box-shadow: inset 0 0 15px #000; }
        .door:hover { transform: scale(1.05); }
        .door.selected { border-color: var(--secondary-color); box-shadow: 0 0 20px var(--secondary-color); }
        .door.opened { background: #111; cursor: default; }
        .door .door-content { font-size: 1.2rem; font-weight: bold; padding: 0.5rem; text-align: center; }
        #threeDoorsChoices { display: none; gap: 1rem; justify-content: center; }

        /* Monopoly Styles */
        #monopolyBoard { display: grid; /* grid-template-columns is set by JS */ gap: 4px; background: #111; padding: 8px; border-radius: 8px; position: relative; }
        .board-cell { width: 100%; padding-top: 100%; position: relative; border-radius: 4px; font-size: 9px; font-weight: bold; color: white; line-height: 1.1; }
        .board-cell-content { position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; justify-content: center; align-items: center; padding: 2px; flex-direction: column; text-align: center;}
        .cell-start { background-color: var(--primary-color); }
        .cell-reward { background-color: var(--success-color); }
        .cell-penalty { background-color: var(--danger-color); }
        .cell-buff { background-color: #3a9a9a; }
        .cell-debuff { background-color: #8b008b; }
        .cell-special { background: linear-gradient(45deg, var(--primary-color), var(--secondary-color)); }
        #playerPiece { position: absolute; width: 20px; height: 20px; background-color: var(--secondary-color); border-radius: 50%; border: 2px solid white; transition: all 0.5s ease-in-out; z-index: 5; box-shadow: 0 0 10px var(--secondary-color); }
        #monopolyInfo { display: flex; justify-content: space-around; align-items: center; gap: 1rem; }
        #monopolyEventText { flex: 1; text-align: center; font-weight: bold; }

        /* Lotto Styles */
        #lottoGrid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 0.5rem; margin: 1rem 0; }
        .lotto-number { padding: 0.8rem; border: 1px solid var(--text-muted-color); border-radius: 50%; cursor: pointer; transition: all 0.2s ease; }
        .lotto-number.selected { background-color: var(--primary-color); color: var(--bg-color); border-color: var(--primary-color); }

    </style>
</head>
<body>

    <div class="container">
        <!-- Header and Timer -->
        <header class="header">
            <h1>æƒ¡é­”çš„è©›å’’</h1>
        </header>
        <div id="timerDisplay" class="timer-display"><span id="timerText">00:00:00</span></div>
        <div id="buff-area"></div>
        
        <!-- Punishments -->
        <div id="timersArea"></div>
        <div id="punishmentArea"></div>

        <!-- Unlock Section -->
        <div id="unlockSection" style="display: none; text-align: center;">
             <p>âœ¨ è©›å’’è¨ˆæ™‚å™¨å·²æ·¨åŒ–ï¼æº–å‚™å¥½è¿æ¥æœ€çµ‚å°æ±ºäº†å—ï¼Ÿ âœ¨</p>
            <button id="unlockBtn" class="btn" style="max-width: 300px; margin: auto;">âš”ï¸ æœ€çµ‚å°æ±º</button>
        </div>

        <!-- Main Controls -->
        <div class="controls-grid">
            <div id="diceCard" class="control-card">
                <h3>èˆ‡å°æƒ¡é­”çš„è³­å±€</h3>
                <p class="charge-info">æ¯ 30 åˆ†é˜æ¢å¾© 1 é»</p>
                <div class="dice-area">
                    <div class="dice-container"><span class="dice-label">ä½ </span><div id="playerDice" class="dice">?</div></div>
                    <div class="dice-container"><span class="dice-label">æƒ¡é­”</span><div id="botDice" class="dice">?</div></div>
                </div>
                <button id="diceBtn" class="btn">æ“²éª°</button>
                <p class="charge-count-display">éˆé­‚ä¹‹åŠ›: <span id="diceCharges">0</span></p>
                <p class="charge-cooldown" id="diceCooldown">ä¸‹æ¬¡æ¢å¾©: ...</p>
            </div>
            
            <div id="slotCard" class="control-card">
                <h3>å‘½é‹ç¥­å£‡</h3>
                <p class="charge-info">æ¯ 30 åˆ†é˜æ¢å¾© 1 é»</p>
                <div class="slot-machine-container"><div id="slotReels" class="slot-reels"></div></div>
                <button id="slotBtn" class="btn">ç¥ˆç¦±</button>
                <p class="charge-count-display">éˆé­‚ä¹‹åŠ›: <span id="slotCharges">0</span></p>
                <p class="charge-cooldown" id="slotCooldown">ä¸‹æ¬¡æ¢å¾©: ...</p>
            </div>

            <div id="rouletteCard" class="control-card">
                <h3>é­”ç¥çš„è¼ªç›¤</h3>
                <p class="charge-info">æ¯ 3 å°æ™‚æ¢å¾© 1 é»</p>
                <p class="description">ç›´é¢é­”ç¥è¨­ä¸‹çš„è‡´å‘½è³­å±€ï¼Œé«˜é¢¨éšªä¹Ÿå¯èƒ½å¸¶ä¾†é«˜å›å ±ã€‚</p>
                <button id="rouletteBtn" class="btn">è½‰å‹•</button>
                <p class="charge-count-display">éˆé­‚ä¹‹åŠ›: <span id="rouletteCharges">0</span></p>
                <p class="charge-cooldown" id="rouletteCooldown">ä¸‹æ¬¡æ¢å¾©: ...</p>
            </div>

            <div id="monopolyCard" class="control-card">
                <h3>æ˜Ÿè¾°æ£‹ç›¤</h3>
                <p class="charge-info">æ¯ 1 å°æ™‚æ¢å¾© 1 é»</p>
                <p class="description">åœ¨ç²¾ç¥ä¸–ç•Œä¸­å±•é–‹æ˜Ÿè¾°ä¹‹æ—…ï¼Œè§¸ç™¼å¤è€ç¬¦æ–‡çš„åŠ›é‡ã€‚</p>
                <button id="monopolyBtn" class="btn">å•Ÿç¨‹</button>
                <p class="charge-count-display">éˆé­‚ä¹‹åŠ›: <span id="monopolyCharges">0</span></p>
                <p class="charge-cooldown" id="monopolyCooldown">ä¸‹æ¬¡æ¢å¾©: ...</p>
            </div>

            <div id="lottoCard" class="control-card">
                <h3>å³æ™‚è–ç±¤</h3>
                <p class="charge-info">æ¯ 3 å°æ™‚æ¢å¾© 1 é»</p>
                <p class="description">å‘ç¥è«­ç¥ˆæ±‚ç«‹å³çš„å•Ÿç¤ºï¼Œçœ‹çœ‹å‘½é‹æ•¸å­—æ˜¯å¦ç«™åœ¨ä½ é€™é‚Šã€‚</p>
                <button id="lottoBtn" class="btn">æ±‚ç±¤</button>
                <p class="charge-count-display">éˆé­‚ä¹‹åŠ›: <span id="lottoCharges">0</span></p>
                <p class="charge-cooldown" id="lottoCooldown">ä¸‹æ¬¡æ¢å¾©: ...</p>
            </div>
            
            <div id="threeDoorsCard" class="control-card">
                <h3>ä¸‰é–€è©¦ç…‰</h3>
                <p class="charge-info">æ¯ 4 å°æ™‚æ¢å¾© 1 é»</p>
                <p class="description">æ™ºæ…§èˆ‡å‹‡æ°£çš„çµ‚æ¥µè€ƒé©—ï¼Œé–€å¾Œæ˜¯ç¥æ©é‚„æ˜¯å¢®è½é™·é˜±ï¼Ÿ</p>
                <button id="threeDoorsBtn" class="btn">æŒ‘æˆ°</button>
                <p class="charge-count-display">éˆé­‚ä¹‹åŠ›: <span id="threeDoorsCharges">0</span></p>
                <p class="charge-cooldown" id="threeDoorsCooldown">ä¸‹æ¬¡æ¢å¾©: ...</p>
            </div>
        </div>

        <!-- Log -->
        <div class="log-section">
            <h3>ğŸ“œ è©¦ç…‰ç´€éŒ„</h3>
            <div id="eventLog"></div>
        </div>

        <button id="newChallengeBtn" class="btn btn-danger">æ¥å—æ–°çš„è©¦ç…‰</button>
    </div>
    
    <!-- Modals -->
    <div id="difficultyModal" class="modal-overlay">
        <div class="modal-content">
            <h2>é¸æ“‡è©¦ç…‰å¼·åº¦</h2>
            <p>è©›å’’çš„å¼·åº¦å°‡æ±ºå®šæ‰€æœ‰è–å…‰æ·¨åŒ–èˆ‡é­”ç¥ä½èªçš„æ•ˆæœã€‚</p>
            <div id="difficultySelection">
                <button class="btn" data-level="1" data-multiplier="1.0">ç­‰ç´š1 (æ–°æ‰‹ x1.0)</button>
                <button class="btn" data-level="2" data-multiplier="1.5">ç­‰ç´š2 (ç†Ÿç·´ x1.5)</button>
                <button class="btn" data-level="3" data-multiplier="2.25">ç­‰ç´š3 (ç²¾è‹± x2.25)</button>
                <button class="btn" data-level="4" data-multiplier="3.375">ç­‰ç´š4 (å°ˆå®¶ x3.375)</button>
                <button class="btn btn-danger" data-level="5" data-multiplier="5.0625">ç­‰ç´š5 (å‚³èªª x5.0625)</button>
            </div>
        </div>
    </div>
    
    <div id="finalUnlockModal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="finalUnlockTitle"></h2>
            <p id="finalUnlockMessage"></p>
            <button id="finalUnlockCloseBtn" class="btn">æˆ‘æ˜ç™½äº†</button>
        </div>
    </div>

    <div id="rouletteModal" class="modal-overlay">
        <div class="modal-content">
            <h2>é­”ç¥çš„è¼ªç›¤</h2>
            <div class="roulette-container">
                <div id="rouletteWheel"></div>
                <div id="roulettePointer"></div>
            </div>
            <p id="rouletteResultText">ä¸‹æ³¨ä¾†æ±ºå®šä½ çš„å‘½é‹ï¼</p>
            <p id="rouletteCurrentBet"></p>
            <div id="rouletteBets">
                <p><strong>ä¸‹æ³¨å°‡é å…ˆæ”¯ä»˜æ™‚é–“ä½œç‚ºç¥­å“ï¼</strong></p>
                <button class="btn" data-bet-type="color" data-bet-value="red">ç©©å¥ä¸‹æ³¨: ç´…è‰² (-15m)</button>
                <button class="btn" data-bet-type="color" data-bet-value="black">ç©©å¥ä¸‹æ³¨: é»‘è‰² (-15m)</button>
                <br>
                <input type="number" id="specificBetInput" placeholder="ç²¾æº–ä¸‹æ³¨æ ¼è™Ÿ (0-11)" min="0" max="11" style="padding: 0.5rem; border-radius: 0.5rem; border: 1px solid #888; background: #333; color: white; width: 200px; margin-right: 10px;">
                <button id="specificBetBtn" class="btn">ä¸‹æ³¨ (-30m)</button>
            </div>
            <div>
                <button id="spinRouletteBtn" class="btn" style="margin-top: 1rem;">é–‹å§‹è½‰å‹•ï¼</button>
                <button class="btn" onclick="closeModal('rouletteModal')">é›¢é–‹</button>
            </div>
        </div>
    </div>

    <div id="monopolyModal" class="modal-overlay">
        <div class="modal-content">
            <h2>æ˜Ÿè¾°æ£‹ç›¤</h2>
            <div id="monopolyBoard"><div id="playerPiece"></div></div>
            <div id="monopolyInfo">
                <div id="monopolyDiceResult" class="dice">?</div>
                <button id="monopolyRollBtn" class="btn" style="width: auto;">æ“²éª°å‰é€²</button>
                <p id="monopolyEventText">æ“²éª°ä¾†æ±ºå®šä½ çš„å‘½é‹ï¼</p>
            </div>
            <button class="btn" onclick="closeModal('monopolyModal')">é›¢é–‹æ£‹ç›¤</button>
        </div>
    </div>

    <div id="lottoModal" class="modal-overlay">
        <div class="modal-content">
            <h2>å³æ™‚è–ç±¤</h2>
            <p>é¸æ“‡ 5 å€‹å¹¸é‹æ•¸å­— (1-30)ã€‚</p>
            <div id="lottoGrid"></div>
            <p>å·²é¸è™Ÿç¢¼: <span id="lottoSelectionText"></span></p>
            <p id="lottoResultArea" style="font-weight: bold;"></p>
            <div>
                <button id="drawLottoBtn" class="btn" disabled>ç«‹å³é–‹ç</button>
                <button class="btn" onclick="closeModal('lottoModal')">é—œé–‰</button>
            </div>
        </div>
    </div>

    <div id="scribeModal" class="modal-overlay">
        <div class="modal-content">
            <h2>å¿ƒå¿—è©¦ç…‰ï¼šæŠ„å¯«è–è¨€</h2>
            <p>è«‹åœ¨ç¾å¯¦ä¸­æŠ„å¯«ä»¥ä¸‹æ–‡å­—ä¸€éï¼Œå®Œæˆå¾Œé»æ“ŠæŒ‰éˆ•ã€‚</p>
            <p id="scribeText" style="background: #111; padding: 1rem; border-radius: 0.5rem; border: 1px solid #444;"></p>
            <button id="scribeConfirmBtn" class="btn">æˆ‘å·²å®ŒæˆæŠ„å¯«</button>
        </div>
    </div>

    <div id="threeDoorsModal" class="modal-overlay">
        <div class="modal-content">
            <h2>ä¸‰é–€è©¦ç…‰</h2>
            <p id="threeDoorsMessage">é¸æ“‡ä¸€æ‰‡é–€ï¼Œçœ‹çœ‹ä½ çš„å‘½é‹å¦‚ä½•ï¼</p>
            <div id="threeDoorsContainer">
                <div class="door" data-index="0"><span>?</span></div>
                <div class="door" data-index="1"><span>?</span></div>
                <div class="door" data-index="2"><span>?</span></div>
            </div>
            <div id="threeDoorsChoices">
                <button id="stickBtn" class="btn">å …æŒé¸æ“‡</button>
                <button id="switchBtn" class="btn">äº¤æ›é¸æ“‡</button>
            </div>
        </div>
    </div>

    <script>
    // --- æƒ¡é­”çš„è©›å’’ v1.0 éŠæˆ²è…³æœ¬ ---
    
    // --- DOM å…ƒç´  ---
    const elements = {
        timerText: document.getElementById('timerText'),
        unlockSection: document.getElementById('unlockSection'),
        unlockBtn: document.getElementById('unlockBtn'),
        newChallengeBtn: document.getElementById('newChallengeBtn'),
        eventLog: document.getElementById('eventLog'),
        buffArea: document.getElementById('buff-area'),
        
        diceBtn: document.getElementById('diceBtn'),
        diceChargesSpan: document.getElementById('diceCharges'),
        playerDiceDiv: document.getElementById('playerDice'),
        botDiceDiv: document.getElementById('botDice'),
        diceCooldown: document.getElementById('diceCooldown'),
        
        slotBtn: document.getElementById('slotBtn'),
        slotReels: document.getElementById('slotReels'),
        slotChargesSpan: document.getElementById('slotCharges'),
        slotCooldown: document.getElementById('slotCooldown'),

        rouletteBtn: document.getElementById('rouletteBtn'),
        rouletteChargesSpan: document.getElementById('rouletteCharges'),
        rouletteModal: document.getElementById('rouletteModal'),
        rouletteWheel: document.getElementById('rouletteWheel'),
        rouletteResultText: document.getElementById('rouletteResultText'),
        rouletteCurrentBet: document.getElementById('rouletteCurrentBet'),
        spinRouletteBtn: document.getElementById('spinRouletteBtn'),
        specificBetBtn: document.getElementById('specificBetBtn'),
        rouletteCooldown: document.getElementById('rouletteCooldown'),

        monopolyBtn: document.getElementById('monopolyBtn'),
        monopolyChargesSpan: document.getElementById('monopolyCharges'),
        monopolyModal: document.getElementById('monopolyModal'),
        monopolyBoard: document.getElementById('monopolyBoard'),
        monopolyRollBtn: document.getElementById('monopolyRollBtn'),
        monopolyDiceResult: document.getElementById('monopolyDiceResult'),
        monopolyEventText: document.getElementById('monopolyEventText'),
        monopolyCooldown: document.getElementById('monopolyCooldown'),

        lottoBtn: document.getElementById('lottoBtn'),
        lottoModal: document.getElementById('lottoModal'),
        lottoGrid: document.getElementById('lottoGrid'),
        lottoSelectionText: document.getElementById('lottoSelectionText'),
        drawLottoBtn: document.getElementById('drawLottoBtn'),
        lottoResultArea: document.getElementById('lottoResultArea'),
        lottoCharges: document.getElementById('lottoCharges'),
        lottoCooldown: document.getElementById('lottoCooldown'),
        
        threeDoorsBtn: document.getElementById('threeDoorsBtn'),
        threeDoorsModal: document.getElementById('threeDoorsModal'),
        threeDoorsContainer: document.getElementById('threeDoorsContainer'),
        threeDoorsMessage: document.getElementById('threeDoorsMessage'),
        threeDoorsChoices: document.getElementById('threeDoorsChoices'),
        threeDoorsCharges: document.getElementById('threeDoorsCharges'),
        threeDoorsCooldown: document.getElementById('threeDoorsCooldown'),
        
        timersArea: document.getElementById('timersArea'),
        punishmentArea: document.getElementById('punishmentArea'),
        scribeModal: document.getElementById('scribeModal'),
        scribeText: document.getElementById('scribeText'),
        scribeConfirmBtn: document.getElementById('scribeConfirmBtn'),

        difficultyModal: document.getElementById('difficultyModal'),
        difficultySelection: document.getElementById('difficultySelection'),
        finalUnlockModal: document.getElementById('finalUnlockModal'),
        finalUnlockCloseBtn: document.getElementById('finalUnlockCloseBtn'),
    };

    // --- éŠæˆ²ç‹€æ…‹ ---
    let gameState = {};
    let timerInterval;
    let monopolyCellCoords = [];
    let lottoSelection = [];
    let threeDoorsState = {};

    const defaultGameState = {
        startTime: null, targetTime: null, totalChallengeTime: 0,
        difficulty: 1, difficultyMultiplier: 1.0,
        chargeTimers: { dice: 0, slot: 0, roulette: 0, monopoly: 0, lotto: 0, threeDoors: 0 },
        diceCharges: 1, slotCharges: 1, rouletteCharges: 1, monopolyCharges: 1, lottoCharges: 1, threeDoorsCharges: 1,
        timers: [], 
        punishments: {}, 
        monopolyPosition: 0, monopolyBoardMap: [],
        activeBuffs: {}, 
        lastSlotResult: null, 
        eventLog: [],
    };

    // --- éŠæˆ²æ•¸æ“š ---
    const intervals = {
        dice: 30 * 60 * 1000, 
        slot: 30 * 60 * 1000,
        roulette: 3 * 60 * 60 * 1000, 
        monopoly: 1 * 60 * 60 * 1000,
        lotto: 3 * 60 * 60 * 1000,
        threeDoors: 4 * 60 * 60 * 1000,
    };
    
    const scribeQuotes = [
        "æ„å¿—çš„å‹åˆ©ï¼Œå§‹æ–¼æœ€å¾®å°çš„å …æŒã€‚",
        "é»‘æš—æ„ˆæ˜¯æ·±é‚ƒï¼Œå°‹æ‰¾å…‰æ˜çš„æ±ºå¿ƒä¾¿æ„ˆæ˜¯ç†¾ç†±ã€‚",
        "æ¯ä¸€æ¬¡å‘¼å¸ï¼Œéƒ½æ˜¯å°æŠ—è©›å’’çš„ç„¡è²æˆ°å¼ã€‚",
        "çœŸæ­£çš„å‹‡è€…ï¼Œä¸æ˜¯å¾ä¸ç•æ‡¼ï¼Œè€Œæ˜¯åœ¨é¡«æŠ–ä¸­ä¾ç„¶å‰è¡Œã€‚",
        "æŸç¸›ä½ çš„ä¸æ˜¯é–éˆï¼Œè€Œæ˜¯ä½ ä»¥ç‚ºç„¡æ³•æ™è„«çš„å¿µé ­ã€‚"
    ];

    const buffDescriptions = {
        'å¼·åŒ–': 'ä¸‹æ¬¡ã€Œèˆ‡å°æƒ¡é­”çš„è³­å±€ã€å‹åˆ©æ™‚çå‹µç¿»å€ (ä¸€æ¬¡æ€§)ã€‚',
        'é çŸ¥': 'ä¸‹æ¬¡ã€Œå‘½é‹ç¥­å£‡ã€çš„çµæœå°‡è¢«é å…ˆæ­ç¤º (ä¸€æ¬¡æ€§)ã€‚',
        'å¹¸é‹': 'ä¸‹æ¬¡ã€Œå‘½é‹ç¥­å£‡ã€å°‡ç§»é™¤æ‰€æœ‰è² é¢çµæœ (ä¸€æ¬¡æ€§)ã€‚',
        'åŠ é€Ÿ': 'æ‰€æœ‰éˆé­‚ä¹‹åŠ›çš„æ¢å¾©é€Ÿåº¦ x2ã€‚',
        'å …éŸŒ': 'æ‰€æœ‰ã€Œé­”ç¥ä½èªã€æ•ˆæœæ¸›å°‘ 50%ã€‚',
        'å¯Œè¶³': 'ä¸‹æ¬¡é€šéã€Œæ˜Ÿè¾°æ£‹ç›¤ã€èµ·é»æ™‚çå‹µç¿»å€ (ä¸€æ¬¡æ€§)ã€‚',
        'è™›å¼±': 'ä¸‹æ¬¡ã€Œèˆ‡å°æƒ¡é­”çš„è³­å±€ã€å¤±æ•—æ™‚æ‡²ç½°ç¿»å€ (ä¸€æ¬¡æ€§)ã€‚',
        'å„é‹': 'ä¸‹æ¬¡ã€Œå‘½é‹ç¥­å£‡ã€å°‡ç§»é™¤æ‰€æœ‰æ­£é¢çµæœ (ä¸€æ¬¡æ€§)ã€‚',
        'é²ç·©': 'æ‰€æœ‰éˆé­‚ä¹‹åŠ›çš„æ¢å¾©æš«æ™‚åœæ­¢ã€‚',
        'è„†å¼±': 'æ‰€æœ‰ã€Œé­”ç¥ä½èªã€æ•ˆæœå¢åŠ  50%ã€‚',
    };
    
    const diceFaces = ['âš€', 'âš', 'âš‚', 'âšƒ', 'âš„', 'âš…'];
    const slotOutcomes = [
        { text: "-4h", type: 'reward', value: -4 * 3600 }, { text: "-2h", type: 'reward', value: -2 * 3600 },
        { text: "-1h", type: 'reward', value: -1 * 3600 }, { text: "+4h", type: 'penalty', value: 4 * 3600 },
        { text: "+2h", type: 'penalty', value: 2 * 3600 }, { text: "+1h", type: 'penalty', value: 1 * 3600 },
        { text: "è²æ“é–-30m", type: 'special', effect: 'reduce_timer', payload: 'chastity_lock' },
        { text: "é«”èƒ½è©¦ç…‰", type: 'special', effect: 'add_punishment', payload: 'random_physical' },
    ];
    const rouletteOutcomes = [
        { text: "-24h", type: 'reward', value: -24*3600, color: 'gold' }, { text: "+24h", type: 'penalty', value: 24*3600, color: 'black' },
        { text: "-3h", type: 'reward', value: -3*3600, color: 'red' }, { text: "+4h", type: 'penalty', value: 4*3600, color: 'black' },
        { text: "-1h", type: 'reward', value: -1*3600, color: 'red' }, { text: "+2h", type: 'penalty', value: 2*3600, color: 'black' },
        { text: "éˆé­‚ä¹‹åŠ›+1", type: 'special', effect: 'all_charges_plus_one', color: 'red' }, { text: "+1h", type: 'penalty', value: 1*3600, color: 'black' },
        { text: "è²æ“é–è©¦ç…‰", type: 'special', effect: 'add_timer', payload: 'chastity_lock' }, { text: "-1h", type: 'reward', value: -1*3600, color: 'red' },
        { text: "é«”èƒ½è©¦ç…‰", type: 'special', effect: 'add_punishment', payload: 'random_physical' }, { text: "-3h", type: 'reward', value: -3*3600, color: 'red' },
    ];

    // --- Initialization ---
    function initializeGame() {
        loadState();
        renderSlotMachine();
        buildRouletteWheel();
        buildLottoGrid();
        
        if (!gameState.targetTime) {
            timerText.textContent = "00:00:00";
            disableAllControls();
            elements.unlockSection.style.display = 'none';
            elements.newChallengeBtn.style.display = 'block';
        } else {
            startTimer();
            elements.newChallengeBtn.style.display = 'none';
            if (gameState.monopolyBoardMap.length > 0) renderMonopolyBoard();
        }
        updateUI();
    }

    // --- Core Game Loop & UI Updates ---
    function startNewChallenge(level, multiplier) {
        elements.difficultyModal.style.display = 'none';
        const initialHours = Math.random() * 12 + 12; // Random 12-24 hours
        const initialDuration = Math.floor(initialHours * 3600 * 1000 * multiplier); // Multiplied by difficulty
        const now = Date.now();
        
        gameState = JSON.parse(JSON.stringify(defaultGameState));
        gameState.difficulty = level;
        gameState.difficultyMultiplier = multiplier;
        gameState.startTime = now;
        gameState.targetTime = now + initialDuration;
        gameState.totalChallengeTime = initialDuration;
        
        // Setup initial charge timers
        gameState.chargeTimers = {
            dice: now + intervals.dice,
            slot: now + intervals.slot,
            roulette: now + intervals.roulette,
            monopoly: now + intervals.monopoly,
            lotto: now + intervals.lotto,
            threeDoors: now + intervals.threeDoors,
        };
        
        generateMonopolyBoard();
        renderMonopolyBoard();

        logEvent(`ğŸŒ± ç­‰ç´š ${level} (x${multiplier}) è©¦ç…‰é–‹å§‹ï¼åˆå§‹è©›å’’æ™‚é•·ï¼š${formatDuration(initialDuration / 1000)}ã€‚`);
        saveState();
        startTimer();
        elements.newChallengeBtn.style.display = 'none';
        elements.unlockSection.style.display = 'none';
        updateUI();
    }

    function startTimer() {
        if (timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(update, 1000);
    }

    function update() {
        if (!gameState.targetTime) {
            clearInterval(timerInterval);
            timerInterval = null;
            return;
        }

        const now = Date.now();
        let remaining = Math.round((gameState.targetTime - now) / 1000);

        if (remaining <= 0) {
            elements.timerText.textContent = "00:00:00";
            if(timerInterval) clearInterval(timerInterval);
            timerInterval = null;
            gameState.targetTime = null; 
            saveState();
            elements.unlockSection.style.display = 'block';
            elements.unlockBtn.disabled = false;
            disableAllControls();
        } else {
            updateCharges();
            updateBuffs();
            updateAllTimers();
        }
        
        updateTimerDisplay();
        updateButtonStates();
        updateCooldownDisplays();
    }
    
    function updateCharges() {
        const now = Date.now();
        const buff = getActiveBuff('é²ç·©');
        if (buff) {
            const timeToAdd = now - (gameState.lastChargeCalcTime || now);
            Object.keys(gameState.chargeTimers).forEach(key => {
                gameState.chargeTimers[key] += timeToAdd;
            });
            gameState.lastChargeCalcTime = now;
            return;
        }
        
        let stateChanged = false;
        const speedMultiplier = getActiveBuff('åŠ é€Ÿ') ? 2 : 1;

        Object.keys(gameState.chargeTimers).forEach(key => {
            const interval = intervals[key] / speedMultiplier;
            if (now >= gameState.chargeTimers[key]) {
                const chargesToAdd = Math.floor((now - gameState.chargeTimers[key]) / interval) + 1;
                gameState[key + 'Charges'] += chargesToAdd;
                gameState.chargeTimers[key] += chargesToAdd * interval;
                stateChanged = true;
            }
        });
        
        gameState.lastChargeCalcTime = now;
        if (stateChanged) saveState();
    }
    
    function updateCooldownDisplays() {
        const now = Date.now();
        const buff = getActiveBuff('é²ç·©');
        
        Object.keys(elements).forEach(key => {
            if (key.endsWith('Cooldown')) {
                const feature = key.replace('Cooldown', '');
                if (gameState.chargeTimers && gameState.chargeTimers[feature] !== undefined) {
                    if (buff) {
                        elements[key].textContent = 'ä¸‹æ¬¡æ¢å¾©: æš«åœä¸­';
                    } else {
                        const remaining = Math.max(0, gameState.chargeTimers[feature] - now);
                        elements[key].textContent = `ä¸‹æ¬¡æ¢å¾©: ${formatDuration(remaining / 1000)}`;
                    }
                }
            }
        });
    }

    function updateBuffs() {
        const now = Date.now();
        let changed = false;
        for (const id in gameState.activeBuffs) {
            if (now > gameState.activeBuffs[id].expiry && gameState.activeBuffs[id].value !== true) {
                logEvent(`âœ¨ æ•ˆæœçµæŸï¼š[${gameState.activeBuffs[id].name}]`);
                delete gameState.activeBuffs[id];
                changed = true;
            }
        }
        if (changed) {
            renderBuffs();
            saveState();
        }
    }

    function updateUI() {
        updateTimerDisplay();
        updateButtonStates();
        updateCooldownDisplays();
        renderLog();
        renderBuffs();
        renderAllTimers();
        renderPunishments();
    }
    
    function updateButtonStates() {
        elements.diceChargesSpan.textContent = gameState.diceCharges;
        elements.diceBtn.disabled = gameState.diceCharges <= 0;
        elements.slotChargesSpan.textContent = gameState.slotCharges;
        elements.slotBtn.disabled = gameState.slotCharges <= 0;
        elements.rouletteChargesSpan.textContent = gameState.rouletteCharges;
        elements.rouletteBtn.disabled = gameState.rouletteCharges <= 0;
        elements.monopolyChargesSpan.textContent = gameState.monopolyCharges;
        elements.monopolyBtn.disabled = gameState.monopolyCharges <= 0;
        elements.lottoCharges.textContent = gameState.lottoCharges;
        elements.lottoBtn.disabled = gameState.lottoCharges <= 0;
        elements.threeDoorsCharges.textContent = gameState.threeDoorsCharges;
        elements.threeDoorsBtn.disabled = gameState.threeDoorsCharges <= 0;
    }

    function disableAllControls() {
        elements.diceBtn.disabled = true;
        elements.slotBtn.disabled = true;
        elements.rouletteBtn.disabled = true;
        elements.monopolyBtn.disabled = true;
        elements.lottoBtn.disabled = true;
        elements.threeDoorsBtn.disabled = true;
    }

    // --- Utility Functions ---
    function formatDuration(totalSeconds) {
        if (totalSeconds < 0) totalSeconds = 0;
        const h = String(Math.floor(totalSeconds / 3600)).padStart(2, '0');
        const m = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2, '0');
        const s = String(Math.floor(totalSeconds % 60)).padStart(2, '0');
        return `${h}:${m}:${s}`;
    }

    function logEvent(message) {
        const timestamp = new Date().toLocaleString('zh-TW', { hour12: false });
        const fullMessage = `[${timestamp}] ${message}`;
        gameState.eventLog.unshift(fullMessage);
        if (gameState.eventLog.length > 100) gameState.eventLog.pop();
        renderLog();
    }
    
    function saveState() {
        localStorage.setItem('devilCurseGameState_v1.1', JSON.stringify(gameState));
    }

    function loadState() {
        const savedState = localStorage.getItem('devilCurseGameState_v1.1');
        if (savedState) {
            const parsedState = JSON.parse(savedState);
            gameState = { ...defaultGameState, ...parsedState };
            gameState.activeBuffs = parsedState.activeBuffs || {};
            gameState.chargeTimers = parsedState.chargeTimers || { dice: 0, slot: 0, roulette: 0, monopoly: 0, lotto: 0, threeDoors: 0 };
            gameState.timers = parsedState.timers || [];
            gameState.punishments = parsedState.punishments || {};
        } else {
            gameState = JSON.parse(JSON.stringify(defaultGameState));
        }
    }

    function modifyTime(seconds, useMultiplier = true) {
        let multiplier = useMultiplier ? gameState.difficultyMultiplier : 1;
        
        const toughBuff = getActiveBuff('å …éŸŒ');
        const fragileBuff = getActiveBuff('è„†å¼±');
        if (seconds > 0 && toughBuff) multiplier *= 0.5;
        if (seconds > 0 && fragileBuff) multiplier *= 1.5;

        const finalSeconds = Math.round(seconds * multiplier);
        if (!gameState.targetTime) gameState.targetTime = Date.now();
        gameState.targetTime += finalSeconds * 1000;

        const msg = finalSeconds > 0 ? `é­”ç¥ä½èª: +${formatDuration(Math.abs(finalSeconds))}` : `è–å…‰æ·¨åŒ–: -${formatDuration(Math.abs(finalSeconds))}`;
        logEvent(`â±ï¸ ${msg}ã€‚`);
        updateTimerDisplay();
        saveState();
    }
    
    function getActiveBuff(name) {
        for (const id in gameState.activeBuffs) {
            if (gameState.activeBuffs[id].name === name) return gameState.activeBuffs[id];
        }
        return null;
    }

    function addBuff(name, durationMinutes, value = null) {
        const id = Date.now();
        const expiry = id + durationMinutes * 60 * 1000;
        gameState.activeBuffs[id] = { name, expiry, value };
        logEvent(`ğŸŸ© ç¥è–åŠ è­·ï¼šç²å¾— [${name}]ï¼`);
        renderBuffs();
    }
    
    function renderBuffs() {
        elements.buffArea.innerHTML = '';
        for (const id in gameState.activeBuffs) {
            const buff = gameState.activeBuffs[id];
            const isDebuff = ['è™›å¼±', 'å„é‹', 'é²ç·©', 'è„†å¼±'].includes(buff.name);
            const remaining = Math.ceil((buff.expiry - Date.now()) / 60000);
            
            const el = document.createElement('div');
            el.className = `buff-item ${isDebuff ? 'debuff' : 'buff'}`;
            
            const header = document.createElement('div');
            header.className = `buff-header ${isDebuff ? 'debuff' : 'buff'}`;
            const durationText = buff.value === true ? '(ä¸€æ¬¡æ€§)' : `(å‰©é¤˜ ${remaining}m)`;
            header.textContent = `[${buff.name}] ${durationText}`;
            
            const description = document.createElement('div');
            description.className = 'buff-description';
            description.textContent = buffDescriptions[buff.name] || 'æœªçŸ¥æ•ˆæœ';
            
            el.appendChild(header);
            el.appendChild(description);
            
            elements.buffArea.appendChild(el);
        }
    }

    function openModal(modalId) { document.getElementById(modalId).style.display = 'flex'; }
    function closeModal(modalId) { document.getElementById(modalId).style.display = 'none'; }
    
    // --- Render Functions ---
    function renderLog() { elements.eventLog.innerHTML = gameState.eventLog.map(msg => `<p>${msg}</p>`).join(''); }
    function updateTimerDisplay() {
        const remaining = gameState.targetTime ? Math.round((gameState.targetTime - Date.now()) / 1000) : 0;
        elements.timerText.textContent = formatDuration(Math.max(0, remaining));
    }
    function renderSlotMachine() {
        elements.slotReels.innerHTML = '';
        const reelItems = [...slotOutcomes, ...slotOutcomes, ...slotOutcomes];
        reelItems.forEach(item => {
            const itemEl = document.createElement('div');
            itemEl.className = `slot-item ${item.type}`;
            itemEl.textContent = item.text;
            elements.slotReels.appendChild(itemEl);
        });
    }

    // --- Feature Implementations ---

    // 1. Dice Duel
    function rollDice() {
        if (gameState.diceCharges <= 0) return;
        gameState.diceCharges--;

        const playerRoll1 = Math.floor(Math.random() * 6) + 1;
        const playerRoll2 = Math.floor(Math.random() * 6) + 1;
        const botRoll1 = Math.floor(Math.random() * 6) + 1;
        const botRoll2 = Math.floor(Math.random() * 6) + 1;
        let playerSum = playerRoll1 + playerRoll2;
        let botSum = botRoll1 + botRoll2;

        elements.playerDiceDiv.textContent = playerSum;
        elements.botDiceDiv.textContent = botSum;
        
        let difference = playerSum - botSum;
        let timeChangeSeconds = difference * -30 * 60;
        
        const strengthenBuff = getActiveBuff('å¼·åŒ–');
        const weakenBuff = getActiveBuff('è™›å¼±');
        
        logEvent(`ğŸ² èˆ‡å°æƒ¡é­”çš„è³­å±€ï¼šä½ æ“²å‡º ${playerSum} é»ï¼Œæƒ¡é­”æ“²å‡º ${botSum} é»ã€‚`);
        
        if (timeChangeSeconds < 0 && strengthenBuff) {
            timeChangeSeconds *= 2;
            logEvent(`ğŸ’ª[å¼·åŒ–]æ•ˆæœè§¸ç™¼ï¼Œè–å…‰æ·¨åŒ–ä¹‹åŠ›ç¿»å€ï¼`);
            delete gameState.activeBuffs[Object.keys(strengthenBuff)[0]]; // Consume buff
        }
        if (timeChangeSeconds > 0 && weakenBuff) {
            timeChangeSeconds *= 2;
            logEvent(`ğŸ’€[è™›å¼±]æ•ˆæœè§¸ç™¼ï¼Œé­”ç¥ä½èªä¹‹åŠ›ç¿»å€ï¼`);
            delete gameState.activeBuffs[Object.keys(weakenBuff)[0]]; // Consume buff
        }

        if (timeChangeSeconds !== 0) {
             modifyTime(timeChangeSeconds);
        } else {
            logEvent(`ğŸ² å¹³æ‰‹ï¼è©›å’’æ²’æœ‰è®ŠåŒ–ã€‚`);
        }
        
        updateUI();
        saveState();
    }

    // 2. Slot Machine
    function pullSlotMachine() {
        if (gameState.slotCharges <= 0) return;
        gameState.slotCharges--;
        elements.slotBtn.disabled = true;

        let currentPool = [...slotOutcomes];
        const luckyBuff = getActiveBuff('å¹¸é‹');
        const unluckyBuff = getActiveBuff('å„é‹');
        const foresightBuff = getActiveBuff('é çŸ¥');
        
        if (luckyBuff) {
            currentPool = currentPool.filter(o => o.type !== 'penalty');
            logEvent('ğŸ€[å¹¸é‹]ç¥æ©è§¸ç™¼ï¼Œç¥­å£‡ç§»é™¤äº†æ‰€æœ‰æƒ¡æ„ï¼');
            delete gameState.activeBuffs[Object.keys(luckyBuff)[0]];
        }
        if (unluckyBuff) {
            currentPool = currentPool.filter(o => o.type !== 'reward');
            logEvent('ğŸ˜ˆ[å„é‹]è©›å’’è§¸ç™¼ï¼Œç¥­å£‡ç§»é™¤äº†æ‰€æœ‰ç¥æ©ï¼');
            delete gameState.activeBuffs[Object.keys(unluckyBuff)[0]];
        }

        const outcome = currentPool[Math.floor(Math.random() * currentPool.length)];
        
        if (foresightBuff) {
            logEvent(`ğŸ‘ï¸[é çŸ¥]ç¥æ©è§¸ç™¼ï¼Œä½ é è¦‹äº†ç¥­å£‡çš„å›æ‡‰æ˜¯ã€Œ${outcome.text}ã€ï¼`);
            delete gameState.activeBuffs[Object.keys(foresightBuff)[0]];
        }
        
        const visualIndex = slotOutcomes.indexOf(outcome);
        const basePosition = slotOutcomes.length * 80;
        const targetPosition = basePosition + (visualIndex * 80);
        
        elements.slotReels.style.transition = 'none';
        elements.slotReels.style.top = '0px';

        setTimeout(() => {
            elements.slotReels.style.transition = 'top 4s cubic-bezier(0.25, 1, 0.5, 1)';
            elements.slotReels.style.top = `-${targetPosition}px`;
        }, 50);

        setTimeout(() => {
            logEvent(`ğŸ° å‘½é‹ç¥­å£‡çš„å›æ‡‰æ˜¯ï¼šã€Œ${outcome.text}ã€ã€‚`);
            gameState.lastSlotResult = outcome;
            if (outcome.value) {
                modifyTime(outcome.value);
            } else if (outcome.effect) {
                handleSpecialOutcome(outcome.effect, outcome.payload);
            }
            updateUI();
            saveState();
        }, 4100);
    }

    // 3. Roulette
    function buildRouletteWheel() {
        elements.rouletteWheel.innerHTML = '';
        const sliceAngle = 360 / rouletteOutcomes.length;
        const colors = rouletteOutcomes.map(s => {
            if (s.color === 'gold') return '#c9a44e';
            if (s.color === 'red') return '#c74242';
            return '#1C1C1C';
        });
        
        let gradientString = 'conic-gradient(';
        for (let i = 0; i < colors.length; i++) {
            gradientString += `${colors[i]} ${i * sliceAngle}deg, ${colors[i]} ${(i + 1) * sliceAngle}deg`;
            if (i < colors.length - 1) {
                gradientString += ', ';
            }
        }
        gradientString += ')';
        elements.rouletteWheel.style.background = gradientString;

        rouletteOutcomes.forEach((slice, i) => {
            const textEl = document.createElement('div');
            textEl.className = 'roulette-slice-text';
            
            const angle = (i * sliceAngle) + (sliceAngle / 2);
            const radius = 105; // 150px (half of wheel) - some padding
            const x = Math.sin(angle * Math.PI / 180) * radius;
            const y = -Math.cos(angle * Math.PI / 180) * radius;
            
            textEl.style.transform = `translate(${x}px, ${y}px) rotate(${angle}deg)`;
            textEl.textContent = slice.text;
            textEl.style.color = slice.color === 'black' ? 'white' : 'black';
            
            elements.rouletteWheel.appendChild(textEl);
        });
    }

    let currentBet = null;
    function setupRoulette() {
        if (gameState.rouletteCharges <= 0) return;
        currentBet = null;
        elements.rouletteResultText.textContent = 'ä¸‹æ³¨ä¾†æ±ºå®šä½ çš„å‘½é‹ï¼';
        elements.rouletteCurrentBet.textContent = 'ç›®å‰ä¸‹æ³¨ï¼šç„¡';
        elements.spinRouletteBtn.disabled = false;
        elements.rouletteWheel.style.transition = 'none';
        elements.rouletteWheel.style.transform = 'rotate(0deg)';
        openModal('rouletteModal');
    }

    function placeRouletteBet(type, value) {
        const cost = type === 'color' ? 15*60 : 30*60;
        modifyTime(cost);
        currentBet = { type, value };
        elements.rouletteCurrentBet.textContent = `ç›®å‰ä¸‹æ³¨ï¼š${type === 'color' ? value === 'red' ? 'ç´…è‰²' : 'é»‘è‰²' : `è™Ÿç¢¼ ${value}`}`;
        logEvent(`ğŸ² è¼ªç›¤ä¸‹æ³¨ï¼š${type === 'color' ? 'é¡è‰²' : 'è™Ÿç¢¼'} ${value}ï¼Œç»ç¥­äº† ${cost/60} åˆ†é˜ã€‚`);
    }

    function spinRoulette() {
        if (gameState.rouletteCharges <= 0) return;
        gameState.rouletteCharges--;
        elements.spinRouletteBtn.disabled = true;

        const randomIndex = Math.floor(Math.random() * rouletteOutcomes.length);
        const outcome = rouletteOutcomes[randomIndex];
        
        const degrees = 360 * 5 + (360 - randomIndex * 30) - 15; // Spin 5 times + land on slice
        elements.rouletteWheel.style.transition = 'transform 6s cubic-bezier(0.2, 0.8, 0.2, 1)';
        elements.rouletteWheel.style.transform = `rotate(${degrees}deg)`;
        
        setTimeout(() => {
            elements.rouletteResultText.textContent = `çµæœæ˜¯ï¼š${outcome.text}!`;
            logEvent(`ğŸ˜ˆ é­”ç¥çš„è¼ªç›¤çµæœï¼š${outcome.text}ï¼`);
            let finalValue = outcome.value || 0;

            // Check bet
            if (currentBet) {
                let win = false;
                if (currentBet.type === 'color' && currentBet.value === outcome.color) win = true;
                if (currentBet.type === 'specific' && currentBet.value == randomIndex) win = true; // Use == for type coercion

                if (win && finalValue < 0) {
                    const multiplier = currentBet.type === 'color' ? 2 : 3;
                    finalValue *= multiplier;
                    logEvent(`ğŸ’° ä¸‹æ³¨æˆåŠŸï¼è–å…‰æ·¨åŒ–ä¹‹åŠ›è®Šç‚º ${multiplier} å€ï¼`);
                } else if (win) {
                    logEvent(`ğŸ’° ä¸‹æ³¨æˆåŠŸï¼ä½†çµæœä¸æ˜¯æ™‚é–“çå‹µã€‚`);
                } else {
                    logEvent(`ğŸ’¸ ä¸‹æ³¨å¤±æ•—ã€‚`);
                }
            }

            if (finalValue !== 0) modifyTime(finalValue);
            if (outcome.effect) handleSpecialOutcome(outcome.effect, outcome.payload);
            
            updateUI();
            saveState();
        }, 6100);
    }
    
    // 4. Monopoly
    function generateMonopolyBoard() {
        // Fixed board layout based on the user-provided image
        const boardLayout = [
            { type: 'start', text: 'èµ·é» (-3h)', value: -3 * 3600 }, // 0
            { type: 'penalty', text: '+2h', value: 2 * 3600 }, // 1
            { type: 'reward', text: '-1h', value: -1 * 3600 }, // 2
            { type: 'buff', text: 'å¹¸é‹', effect: 'å¹¸é‹', duration: 0 }, // 3
            { type: 'debuff', text: 'å„é‹', effect: 'å„é‹', duration: 0 }, // 4
            { type: 'special', text: 'ç§»é™¤è²æ“é–', effect: 'remove_timer', payload: 'chastity_lock' }, // 5
            { type: 'penalty', text: '+3h', value: 3 * 3600 }, // 6
            { type: 'buff', text: 'å¼·åŒ–', effect: 'å¼·åŒ–', duration: 0 }, // 7
            { type: 'debuff', text: 'è™›å¼±', effect: 'è™›å¼±', duration: 0 }, // 8
            { type: 'special', text: 'æŠ„å¯«è–è¨€', effect: 'add_punishment', payload: 'scribe_penance' }, // 9
            { type: 'penalty', text: '+3h', value: 3 * 3600 }, // 10
            { type: 'buff', text: 'å …éŸŒ', effect: 'å …éŸŒ', duration: 30 }, // 11
            { type: 'debuff', text: 'è„†å¼±', effect: 'è„†å¼±', duration: 30 }, // 12
            { type: 'penalty', text: '+2h', value: 2 * 3600 }, // 13
            { type: 'reward', text: '-2h', value: -2 * 3600 }, // 14
            { type: 'buff', text: 'å¯Œè¶³', effect: 'å¯Œè¶³', duration: 0 }, // 15
            { type: 'special', text: 'è²æ“é–è©¦ç…‰', effect: 'add_timer', payload: 'chastity_lock' }, // 16
            { type: 'reward', text: '-4h', value: -4 * 3600 }, // 17
            { type: 'special', text: 'è¤‡è£½æ‹‰éœ¸(è² )', effect: 'copy_slot_negative' }, // 18
            { type: 'reward', text: '-1h', value: -1 * 3600 }, // 19
            { type: 'reward', text: '-3h', value: -3 * 3600 }, // 20
            { type: 'special', text: 'é«”èƒ½è©¦ç…‰', effect: 'add_punishment', payload: 'random_physical' }, // 21
            { type: 'penalty', text: '+4h', value: 4 * 3600 }, // 22
            { type: 'special', text: 'è²æ“é–è©¦ç…‰', effect: 'add_timer', payload: 'chastity_lock' }, // 23
            { type: 'reward', text: '-1h', value: -1 * 3600 }, // 24
            { type: 'special', text: 'éˆé­‚ä¹‹åŠ›+1', effect: 'all_charges_plus_one' }, // 25
            { type: 'reward', text: '-2h', value: -2 * 3600 }, // 26
            { type: 'reward', text: '-3h', value: -3 * 3600 }, // 27
            { type: 'buff', text: 'åŠ é€Ÿ', effect: 'åŠ é€Ÿ', duration: 60 }, // 28
            { type: 'special', text: 'éˆé­‚ä¹‹åŠ›+1', effect: 'all_charges_plus_one' }, // 29
            { type: 'reward', text: '-1h', value: -1 * 3600 }, // 30
            { type: 'buff', text: 'é çŸ¥', effect: 'é çŸ¥', duration: 0 }, // 31
            { type: 'reward', text: '-2h', value: -2 * 3600 }, // 32
            { type: 'buff', text: 'å …éŸŒ', effect: 'å …éŸŒ', duration: 30 }, // 33
            { type: 'penalty', text: '+2h', value: 2 * 3600 }, // 34
            { type: 'penalty', text: '+2h', value: 2 * 3600 }, // 35
        ];
        gameState.monopolyBoardMap = boardLayout;
    }
    
    function renderMonopolyBoard() {
        const board = elements.monopolyBoard;
        board.innerHTML = '';
        monopolyCellCoords = [];
        const size = 10; // 10x10 grid for this layout
        
        // Hardcode the path based on the image
        // Top row (0-9)
        for (let i = 0; i < 10; i++) monopolyCellCoords.push({ y: 0, x: i });
        // Right col (10-18)
        for (let i = 1; i < 10; i++) monopolyCellCoords.push({ y: i, x: 9 });
        // Bottom row (19-27)
        for (let i = 8; i >= 0; i--) monopolyCellCoords.push({ y: 9, x: i });
        // Left col (28-35)
        for (let i = 8; i >= 1; i--) monopolyCellCoords.push({ y: i, x: 0 });

        // Change grid layout to 10x10
        board.style.gridTemplateColumns = `repeat(${size}, 1fr)`;

        let grid = Array(size).fill(null).map(() => Array(size).fill(null));
        monopolyCellCoords.forEach((coord, index) => {
            if (grid[coord.y] && grid[coord.y][coord.x] === null) {
                grid[coord.y][coord.x] = { ...gameState.monopolyBoardMap[index], index };
            }
        });

        for (let r = 0; r < size; r++) {
            for (let c = 0; c < size; c++) {
                const cellEl = document.createElement('div');
                if (grid[r][c]) {
                    const cellData = grid[r][c];
                    cellEl.className = `board-cell cell-${cellData.type}`;
                    cellEl.innerHTML = `<div class="board-cell-content"><span>${cellData.index}</span><span>${cellData.text}</span></div>`;
                }
                board.appendChild(cellEl);
            }
        }
        board.innerHTML += '<div id="playerPiece"></div>';
        updatePlayerPiecePosition();
    }


    function updatePlayerPiecePosition() {
        const playerPieceEl = document.getElementById('playerPiece');
        if (!playerPieceEl || monopolyCellCoords.length === 0) return;
        const {x, y} = monopolyCellCoords[gameState.monopolyPosition];
        const cellWidth = elements.monopolyBoard.firstChild.offsetWidth;
        playerPieceEl.style.top = `${y * (cellWidth + 4) + cellWidth/2 - playerPieceEl.offsetHeight/2}px`;
        playerPieceEl.style.left = `${x * (cellWidth + 4) + cellWidth/2 - playerPieceEl.offsetWidth/2}px`;
    }

    function setupMonopoly() {
        if (gameState.monopolyCharges <= 0) return;
        elements.monopolyEventText.textContent = "æ“²éª°ä¾†æ±ºå®šä½ çš„å‘½é‹ï¼";
        elements.monopolyDiceResult.textContent = "?";
        openModal('monopolyModal');
        updatePlayerPiecePosition();
    }

    function rollMonopolyDice() {
        if (gameState.monopolyCharges <= 0) return;
        gameState.monopolyCharges--;
        elements.monopolyRollBtn.disabled = true;

        const roll = Math.floor(Math.random() * 6) + 1;
        elements.monopolyDiceResult.textContent = diceFaces[roll - 1];
        
        const oldPosition = gameState.monopolyPosition;
        const newPosition = (oldPosition + roll) % gameState.monopolyBoardMap.length;
        
        // Animate movement
        let currentDisplayPos = oldPosition;
        const moveInterval = setInterval(() => {
            currentDisplayPos = (currentDisplayPos + 1) % gameState.monopolyBoardMap.length;
            gameState.monopolyPosition = currentDisplayPos;
            updatePlayerPiecePosition();
            if (currentDisplayPos === newPosition) {
                clearInterval(moveInterval);
                // Landed, now trigger events
                gameState.monopolyPosition = newPosition;
                if (newPosition < oldPosition) {
                    let reward = -3 * 3600;
                    if (getActiveBuff('å¯Œè¶³')) {
                        reward *= 2;
                        logEvent('ğŸ’°[å¯Œè¶³]ç¥æ©è§¸ç™¼ï¼Œé€šéèµ·é»çå‹µç¿»å€ï¼');
                        delete gameState.activeBuffs[Object.keys(getActiveBuff('å¯Œè¶³'))[0]];
                    }
                    logEvent('âœ¨ ä½ å®Œæˆäº†ä¸€åœˆæ˜Ÿè¾°ä¹‹æ—…ï¼');
                    modifyTime(reward);
                }
                handleMonopolyLand();
                elements.monopolyRollBtn.disabled = false;
            }
        }, 200);
    }
    
    function handleMonopolyLand() {
        const landedCell = gameState.monopolyBoardMap[gameState.monopolyPosition];
        elements.monopolyEventText.textContent = `ç¬¬${gameState.monopolyPosition}æ ¼: ${landedCell.text}`;
        logEvent(`ğŸ—ºï¸ æ˜Ÿè¾°æ£‹ç›¤ï¼šä¾†åˆ°ç¬¬ ${gameState.monopolyPosition} æ ¼ï¼Œè§¸ç™¼ã€Œ${landedCell.text}ã€ï¼`);

        if (landedCell.value) modifyTime(landedCell.value);
        if (landedCell.effect) {
            if (landedCell.duration > 0) {
                addBuff(landedCell.effect, landedCell.duration);
            } else {
                handleSpecialOutcome(landedCell.effect, landedCell.payload);
            }
        }
        if (landedCell.type === 'start') modifyTime(-3*3600);
        
        updateUI();
        saveState();
    }

    // 5. Instant Lotto
    function buildLottoGrid() {
        elements.lottoGrid.innerHTML = '';
        for (let i = 1; i <= 30; i++) {
            const numEl = document.createElement('div');
            numEl.className = 'lotto-number';
            numEl.textContent = i;
            numEl.dataset.number = i;
            numEl.addEventListener('click', () => toggleLottoNumber(i, numEl));
            elements.lottoGrid.appendChild(numEl);
        }
    }
    
    function setupLotto() {
        if (gameState.lottoCharges <= 0) return;
        lottoSelection = [];
        updateLottoSelectionUI();
        elements.lottoResultArea.textContent = '';
        openModal('lottoModal');
    }
    
    function toggleLottoNumber(num, el) {
        const index = lottoSelection.indexOf(num);
        if (index > -1) {
            lottoSelection.splice(index, 1);
        } else if (lottoSelection.length < 5) {
            lottoSelection.push(num);
        }
        updateLottoSelectionUI();
    }
    
    function updateLottoSelectionUI() {
        lottoSelection.sort((a, b) => a - b);
        elements.lottoSelectionText.textContent = lottoSelection.join(', ') || 'å°šæœªé¸æ“‡';
        document.querySelectorAll('.lotto-number').forEach(el => {
            el.classList.toggle('selected', lottoSelection.includes(parseInt(el.dataset.number)));
        });
        elements.drawLottoBtn.disabled = lottoSelection.length !== 5;
    }

    function drawLotto() {
        if (lottoSelection.length !== 5 || gameState.lottoCharges <= 0) return;
        
        gameState.lottoCharges--;
        logEvent(`ğŸŸï¸ ä½ ç»ä¸Šéˆé­‚ä¹‹åŠ›ï¼Œç¥ˆæ±‚è–ç±¤çš„æŒ‡å¼•ï¼Œè™Ÿç¢¼ç‚ºï¼š${lottoSelection.join(', ')}`);
        
        const winningNumbers = new Set();
        while (winningNumbers.size < 5) {
            winningNumbers.add(Math.floor(Math.random() * 30) + 1);
        }
        const winningArray = [...winningNumbers].sort((a,b) => a-b);
        
        const matches = lottoSelection.filter(num => winningNumbers.has(num)).length;
        let reward = 0;
        let rewardText = `ç¥è«­è™Ÿç¢¼: ${winningArray.join(', ')}. ä½ çš„è™Ÿç¢¼: ${lottoSelection.join(', ')}. å¥‘åˆ ${matches} å€‹`;

        if (matches === 5) { reward = -48 * 3600; rewardText += 'ï¼Œé ­çï¼'; }
        else if (matches === 4) { reward = -12 * 3600; rewardText += 'ï¼ŒäºŒçï¼'; }
        else if (matches === 3) { reward = -4 * 3600; rewardText += 'ï¼Œä¸‰çï¼'; }
        else if (matches === 2) { reward = -30 * 60; rewardText += 'ï¼Œæ™®çã€‚'; }
        else { rewardText += 'ï¼Œæœªä¸­çã€‚'; }
        
        elements.lottoResultArea.textContent = rewardText;
        logEvent(`ğŸŸï¸ è–ç±¤çµæœï¼š${rewardText}`);

        if (reward !== 0) modifyTime(reward);
        
        lottoSelection = [];
        updateLottoSelectionUI();
        updateUI();
        saveState();
    }

    // 6. Three Doors of Fate
    function setupThreeDoors() {
        if (gameState.threeDoorsCharges <= 0) return;
        gameState.threeDoorsCharges--;
        
        const [prize, trap1, trap2] = generateThreeDoorsSet();
        let doors = [prize, trap1, trap2];
        for (let i = doors.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [doors[i], doors[j]] = [doors[j], doors[i]];
        }

        threeDoorsState = {
            doors: doors,
            playerChoice: null,
            openedByHost: null,
            step: 1, 
        };

        elements.threeDoorsMessage.innerHTML = `æœ¬å›åˆçå‹µï¼š<strong style="color: var(--success-color);">${prize.text}</strong><br>é™·é˜±ï¼š<strong style="color: var(--danger-color);">${trap1.text}</strong>ã€<strong style="color: var(--danger-color);">${trap2.text}</strong><br>è«‹é¸æ“‡ä¸€æ‰‡é–€ï¼`;
        elements.threeDoorsChoices.style.display = 'none';
        document.querySelectorAll('.door').forEach((door, i) => {
            door.classList.remove('selected', 'opened');
            door.innerHTML = '<span>?</span>';
            door.onclick = () => chooseDoor(i);
        });

        openModal('threeDoorsModal');
    }

    function chooseDoor(index) {
        if (threeDoorsState.step !== 1) return;
        threeDoorsState.playerChoice = index;
        threeDoorsState.step = 2;

        document.querySelectorAll('.door').forEach((door, i) => {
            door.classList.toggle('selected', i === index);
            door.onclick = null; // Disable further clicks
        });

        let doorToOpen;
        for (let i = 0; i < 3; i++) {
            if (i !== threeDoorsState.playerChoice && !threeDoorsState.doors[i].isPrize) {
                doorToOpen = i;
                break;
            }
        }
        
        threeDoorsState.openedByHost = doorToOpen;

        setTimeout(() => {
            const openedDoorEl = document.querySelector(`.door[data-index="${doorToOpen}"]`);
            openedDoorEl.classList.add('opened');
            openedDoorEl.innerHTML = `<div class="door-content">${threeDoorsState.doors[doorToOpen].text}</div>`;
            
            elements.threeDoorsMessage.textContent = `ä¸»æŒäººæ‰“é–‹äº†ä¸€æ‰‡æ‡²ç½°é–€... ä½ ç¢ºå®šä¸æ›å—ï¼Ÿ`;
            elements.threeDoorsChoices.style.display = 'flex';
        }, 1000);
    }
    
    function resolveThreeDoors(switched) {
        const finalChoice = switched ? 
            [0, 1, 2].find(i => i !== threeDoorsState.playerChoice && i !== threeDoorsState.openedByHost) :
            threeDoorsState.playerChoice;
            
        const outcome = threeDoorsState.doors[finalChoice];
        
        document.querySelectorAll('.door').forEach((door, i) => {
            door.classList.add('opened');
            door.innerHTML = `<div class="door-content">${threeDoorsState.doors[i].text}</div>`;
        });
        document.querySelector(`.door[data-index="${finalChoice}"]`).classList.add('selected');
        
        elements.threeDoorsMessage.textContent = `ä½ çš„é¸æ“‡æ˜¯... ${outcome.text}!`;
        elements.threeDoorsChoices.style.display = 'none';
        
        logEvent(`ğŸšª ä¸‰é–€è©¦ç…‰çµæœï¼š${outcome.text}`);
        applyOutcome(outcome);
        
        setTimeout(() => closeModal('threeDoorsModal'), 4000);
        updateUI();
        saveState();
    }

    function generateThreeDoorsSet() {
        const prizeHours = Math.floor(Math.random() * 5) + 8; // 8-12
        const prize = { text: `-${prizeHours}å°æ™‚`, type: 'reward', value: -prizeHours * 3600, isPrize: true };
        
        const timeTrapHours = Math.floor(Math.random() * 5) + 6; // 6-10
        const timeTrap = { text: `+${timeTrapHours}å°æ™‚`, type: 'penalty', value: timeTrapHours * 3600, isPrize: false };

        const realityTraps = [
            { text: 'æ‰‹æ©Ÿæ’æ¯’2å°æ™‚', effect: 'add_timer', payload: 'phone_detox', weight: 10 },
            { text: 'ä¿„ç¾…æ–¯è½‰é«”60æ¬¡', effect: 'add_punishment', payload: 'russian_twist', weight: 25 },
            { text: 'ä»°è‡¥æ‘¸è…³è¸60æ¬¡', effect: 'add_punishment', payload: 'ankle_touch', weight: 25 },
            { text: 'æ·±å–‰åš¨å‡å±Œ10æ¬¡', effect: 'add_punishment', payload: 'dildo_punishment', weight: 20 },
            { text: 'è¶…å¯æ€•çµ„åˆæŠ€', effect: 'super_combo', weight: 15 },
            { text: 'æˆ´é–ç¡è¦º', effect: 'add_punishment', payload: 'chastened_slumber', weight: 5 },
        ];
        
        const weightedPool = [];
        realityTraps.forEach(trap => {
            for(let i=0; i<trap.weight; i++) {
                weightedPool.push(trap);
            }
        });

        const chosenRealityTrap = weightedPool[Math.floor(Math.random() * weightedPool.length)];
        const realityTrap = { text: chosenRealityTrap.text, type: 'special', effect: chosenRealityTrap.effect, payload: chosenRealityTrap.payload, isPrize: false };

        return [prize, timeTrap, realityTrap];
    }
    
    function applyOutcome(outcome) {
        if (outcome.value) modifyTime(outcome.value);
        if (outcome.effect) handleSpecialOutcome(outcome.effect, outcome.payload);
    }


    // Final Unlock & Punishments
    function attemptUnlock() {
        elements.unlockBtn.disabled = true;
        logEvent('âš”ï¸ ä½ é¼“èµ·å‹‡æ°£ï¼Œæº–å‚™èˆ‡è©›å’’çš„æ ¹æºé€²è¡Œæœ€çµ‚å°æ±º...');
        const isSuccess = Math.random() < 0.5;

        setTimeout(() => {
            if (isSuccess) {
                logEvent('ğŸ‰ è–å…‰å‹åˆ©ï¼ä½ æˆåŠŸæ·¨åŒ–äº†è©›å’’ï¼Œé‡ç²è‡ªç”±ï¼');
                showFinalUnlockModal('ğŸ‰ è©¦ç…‰æˆåŠŸï¼', 'æ­å–œä½ ï¼Œå‹‡è€…ï¼ä½ ä»¥ç„¡æ¯”çš„æ„å¿—åŠ›æˆ°å‹äº†é­”ç¥ï¼Œä½ çš„éˆé­‚å†æ¬¡å®Œæ•´ã€‚');
                gameState = {};
                localStorage.removeItem('devilCurseGameState_v1.1');
            } else {
                logEvent('âŒ å°æ±ºå¤±æ•—ï¼é­”ç¥çš„è©›å’’å†æ¬¡å°‡ä½ åå™¬...');
                applyFinalPenalty();
            }
        }, 2000);
    }
    
    function applyFinalPenalty() {
        const rand = Math.random() * 100;
        let penaltyMessage;
        if (rand < 50) { const h = (Math.floor(Math.random()*3)+1); modifyTime(h*3600); penaltyMessage = `é­”ç¥ä½èª(å°)-å¢åŠ ${h}å°æ™‚`; }
        else if (rand < 75) { const h = (Math.floor(Math.random()*4)+3); modifyTime(h*3600); penaltyMessage = `é­”ç¥ä½èª(ä¸­)-å¢åŠ ${h}å°æ™‚`; }
        else if (rand < 85) { const h = (Math.floor(Math.random()*7)+6); modifyTime(h*3600); penaltyMessage = `é­”ç¥ä½èª(å¤§)-å¢åŠ ${h}å°æ™‚`; }
        else if (rand < 95) { penaltyMessage = `æŸç¸›å†ç¾-ç”Ÿæˆ1å°æ™‚è²æ“é–è©¦ç…‰`; addTimer('chastity_lock'); }
        else { const t = gameState.totalChallengeTime/1000; penaltyMessage = `å²è©©ç´šåå™¬-å¢åŠ åˆå§‹ç¸½æ™‚é•·(${formatDuration(t)})`; modifyTime(t, false); }
        
        logEvent(`ğŸ’¥ éˆé­‚åå™¬è§¸ç™¼ï¼š${penaltyMessage}`);
        showFinalUnlockModal('âŒ å°æ±ºå¤±æ•—ï¼', `è§¸ç™¼éˆé­‚åå™¬ï¼š${penaltyMessage}<br>è©¦ç…‰ä»åœ¨ç¹¼çºŒï¼`);
        saveState();
        startTimer();
        updateUI();
    }

    function showFinalUnlockModal(title, message) {
        document.getElementById('finalUnlockTitle').innerHTML = title;
        document.getElementById('finalUnlockMessage').innerHTML = message;
        openModal('finalUnlockModal');
    }
    
    function handleSpecialOutcome(effect, payload) {
        switch(effect) {
            case 'add_punishment':
                if (payload === 'random_physical') {
                    const physicalPunishments = ['wall_sit', 'plank', 'russian_twist', 'ankle_touch'];
                    const randomPunishment = physicalPunishments[Math.floor(Math.random() * physicalPunishments.length)];
                    addPunishment(randomPunishment, 1);
                } else {
                    addPunishment(payload, 1);
                }
                break;
            case 'add_timer':
                addTimer(payload);
                break;
            case 'reduce_timer':
                if (gameState.timers.length > 0) {
                    const timer = gameState.timers.find(t => t.type === payload) || gameState.timers[0];
                    if (timer) {
                        timer.duration -= 30 * 60 * 1000;
                        logEvent(`âœ¨ ç¥è–ç¥ç¦ï¼ä¸€å€‹ã€Œ${timer.name}ã€æ™‚é–“æ¸›å°‘äº†30åˆ†é˜ï¼`);
                    }
                } else { logEvent(`âœ¨ ç¥è–ç¥ç¦ï¼ä½†æ²’æœ‰è¨ˆæ™‚å™¨å¯ä»¥æ¸›å°‘ã€‚`); }
                break;
            case 'all_charges_plus_one':
                Object.keys(gameState.chargeTimers).forEach(key => gameState[key + 'Charges']++);
                logEvent('âš¡ éˆé­‚ä¹‹åŠ›æ¹§ç¾ï¼æ‰€æœ‰å„€å¼çš„éˆé­‚ä¹‹åŠ›+1ï¼');
                break;
            case 'remove_timer':
                const timerIndex = gameState.timers.findIndex(t => t.type === payload);
                if (timerIndex > -1) {
                    const timerName = gameState.timers[timerIndex].name;
                    gameState.timers.splice(timerIndex, 1);
                    logEvent(`ğŸ”“ å¥‡è¹Ÿç™¼ç”Ÿï¼ä¸€å€‹ã€Œ${timerName}ã€è¢«ç§»é™¤äº†ï¼`);
                } else { logEvent('ğŸ¤· æ²’æœ‰å°æ‡‰çš„è¨ˆæ™‚å™¨å¯ä»¥ç§»é™¤ã€‚'); }
                break;
            case 'super_combo':
                logEvent('ğŸ’¥ğŸ’¥ğŸ’¥ è¶…å¯æ€•çµ„åˆæŠ€ï¼ç²å¾—è²æ“é–ã€æ¶¼å·¾ã€åˆ®é¬æ³¡è©¦ç…‰å…¨é¤ï¼');
                addTimer('chastity_lock');
                addPunishment('towel_punishment', 1);
                addPunishment('foam_punishment', 1);
                break;
            case 'copy_slot_positive':
                if (gameState.lastSlotResult && gameState.lastSlotResult.type === 'reward') {
                    logEvent(`ğŸ”„ æ˜Ÿè¾°ä¹‹åŠ›ï¼è¤‡è£½äº†ä¸Šæ¬¡ç¥­å£‡çš„æ­£é¢å›æ‡‰ã€Œ${gameState.lastSlotResult.text}ã€ï¼`);
                    modifyTime(gameState.lastSlotResult.value);
                } else { logEvent('ğŸ¤· æ˜Ÿè¾°ä¹‹åŠ›ç„¡æ³•è¤‡è£½ï¼Œä¸Šæ¬¡ç¥­å£‡æ²’æœ‰æ­£é¢å›æ‡‰ã€‚'); }
                break;
            case 'copy_slot_negative':
                 if (gameState.lastSlotResult && gameState.lastSlotResult.type === 'penalty') {
                    logEvent(`ğŸ’€ æ˜Ÿè¾°ä¹‹åŠ›ï¼è¤‡è£½äº†ä¸Šæ¬¡ç¥­å£‡çš„è² é¢å›æ‡‰ã€Œ${gameState.lastSlotResult.text}ã€ï¼`);
                    modifyTime(gameState.lastSlotResult.value);
                } else { logEvent('ğŸ¤· æ˜Ÿè¾°ä¹‹åŠ›ç„¡æ³•è¤‡è£½ï¼Œä¸Šæ¬¡ç¥­å£‡æ²’æœ‰è² é¢å›æ‡‰ã€‚'); }
                break;
            case 'å¼·åŒ–': case 'é çŸ¥': case 'å¹¸é‹': case 'å¯Œè¶³': case 'è™›å¼±': case 'å„é‹': case 'å …éŸŒ':
                 addBuff(effect, 9999, true); // One-time use buffs
                 break;
        }
        updateUI();
        saveState();
    }

    const timerTypes = {
        'chastity_lock': { name: 'è²æ“é–è©¦ç…‰', duration: 1 * 3600 * 1000, icon: 'â›“ï¸' },
        'phone_detox': { name: 'æ‰‹æ©Ÿæ’æ¯’', duration: 2 * 3600 * 1000, icon: 'ğŸ“µ' },
    };

    function addTimer(type) {
        if (!timerTypes[type]) return;
        const config = timerTypes[type];
        const newTimer = { id: Date.now(), type: type, name: config.name, icon: config.icon, duration: config.duration, startTime: Date.now() };
        gameState.timers.push(newTimer);
        logEvent(`${config.icon} æ–°å¢è¨ˆæ™‚å™¨è©¦ç…‰ï¼šã€Œ${config.name}ã€ï¼`);
        renderAllTimers();
        saveState();
    }

    function updateAllTimers() {
         for (let i = gameState.timers.length - 1; i >= 0; i--) {
            const timer = gameState.timers[i];
            const elapsed = Date.now() - timer.startTime;
            const remaining = timer.duration - elapsed;
            const timerEl = document.getElementById(`timer-${timer.id}`);
            if (remaining <= 0) {
                logEvent(`âœ… è¨ˆæ™‚å™¨è©¦ç…‰å®Œæˆï¼šã€Œ${timer.name}ã€ï¼`);
                if(timerEl) timerEl.remove();
                gameState.timers.splice(i, 1);
                saveState();
            } else if (timerEl) {
                timerEl.querySelector('.timer-time').textContent = formatDuration(remaining / 1000);
            }
        }
    }
    
    function renderAllTimers() {
        elements.timersArea.innerHTML = '';
        gameState.timers.forEach(timer => {
            const el = document.createElement('div');
            el.className = 'status-item timer-item';
            el.id = `timer-${timer.id}`;
            const remaining = timer.duration - (Date.now() - timer.startTime);
            el.innerHTML = `<span>${timer.icon} ${timer.name} (å‰©é¤˜ <span class="timer-time">${formatDuration(remaining / 1000)}</span>)</span><span>é€²è¡Œä¸­...</span>`;
            elements.timersArea.appendChild(el);
        });
    }

    const punishmentTypes = {
        'towel_punishment': { name: 'æ¶¼å·¾è©¦ç…‰', icon: 'ğŸ¥¶' },
        'foam_punishment': { name: 'åˆ®é¬æ³¡è©¦ç…‰', icon: 'â˜ï¸' },
        'dildo_punishment': { name: 'æ·±å–‰åš¨å‡å±Œ10æ¬¡', icon: 'ğŸ†' },
        'russian_twist': { name: 'ä¿„ç¾…æ–¯è½‰é«”60æ¬¡', icon: 'ğŸ’ª' },
        'ankle_touch': { name: 'ä»°è‡¥æ‘¸è…³è¸60æ¬¡', icon: 'ğŸ’ª' },
        'scribe_penance': { name: 'æŠ„å¯«è–è¨€', icon: 'âœï¸' },
        'wall_sit': { name: 'é ç‰†æ·±è¹²30ç§’', icon: 'ğŸ‹ï¸' },
        'plank': { name: 'æ£’å¼æ’é«”45ç§’', icon: 'ğŸ¤¸' },
        'chastened_slumber': { name: 'æˆ´é–ç¡è¦º', icon: 'ğŸŒ™' },
    };

    function addPunishment(type, amount) {
        if (!punishmentTypes[type]) return;

        if (type === 'scribe_penance') {
            const quote = scribeQuotes[Math.floor(Math.random() * scribeQuotes.length)];
            elements.scribeText.textContent = `"${quote}"`;
            openModal('scribeModal');
            elements.scribeConfirmBtn.onclick = () => {
                logEvent(`âœï¸ ä½ å®Œæˆäº†ä¸€æ¬¡æŠ„å¯«è–è¨€ï¼`);
                closeModal('scribeModal');
                saveState();
            };
            return;
        }

        if (!gameState.punishments[type]) {
            gameState.punishments[type] = 0;
        }
        gameState.punishments[type] += amount;
        logEvent(`${punishmentTypes[type].icon} æ–°å¢è©¦ç…‰ï¼šã€Œ${punishmentTypes[type].name}ã€ï¼`);
        renderPunishments();
        saveState();
    }
    
    function renderPunishments() {
        elements.punishmentArea.innerHTML = '';
        for (const type in gameState.punishments) {
            const count = gameState.punishments[type];
            if (count > 0) {
                const config = punishmentTypes[type];
                const el = document.createElement('div');
                el.className = 'status-item punishment-item';
                el.innerHTML = `<span>${config.icon} å¾…åŸ·è¡Œè©¦ç…‰: ${config.name} x ${count}</span><button class="btn btn-sm btn-danger">æˆ‘å·²å®Œæˆ</button>`;
                el.querySelector('button').addEventListener('click', () => { 
                    gameState.punishments[type]--; 
                    logEvent(`${config.icon} ä½ å®Œæˆäº†ä¸€æ¬¡ã€Œ${config.name}ã€è©¦ç…‰ï¼`); 
                    renderPunishments(); 
                    saveState(); 
                });
                elements.punishmentArea.appendChild(el);
            }
        }
    }

    // --- Event Listeners ---
    elements.newChallengeBtn.addEventListener('click', () => openModal('difficultyModal'));
    elements.difficultySelection.addEventListener('click', (e) => {
        if (e.target.tagName === 'BUTTON') {
            startNewChallenge(parseInt(e.target.dataset.level), parseFloat(e.target.dataset.multiplier));
        }
    });
    elements.diceBtn.addEventListener('click', rollDice);
    elements.slotBtn.addEventListener('click', pullSlotMachine);
    elements.rouletteBtn.addEventListener('click', setupRoulette);
    elements.monopolyBtn.addEventListener('click', setupMonopoly);
    elements.lottoBtn.addEventListener('click', setupLotto);
    elements.threeDoorsBtn.addEventListener('click', setupThreeDoors);
    elements.unlockBtn.addEventListener('click', attemptUnlock);
    elements.finalUnlockCloseBtn.addEventListener('click', () => {
        closeModal('finalUnlockModal');
        if (!gameState.targetTime) initializeGame();
    });
    elements.spinRouletteBtn.addEventListener('click', spinRoulette);
    document.querySelectorAll('[data-bet-type="color"]').forEach(btn => {
        btn.addEventListener('click', () => placeRouletteBet('color', btn.dataset.betValue));
    });
    elements.specificBetBtn.addEventListener('click', () => {
        const val = parseInt(document.getElementById('specificBetInput').value);
        if (!isNaN(val) && val >= 0 && val <= 11) placeRouletteBet('specific', val);
    });
    elements.monopolyRollBtn.addEventListener('click', rollMonopolyDice);
    elements.drawLottoBtn.addEventListener('click', drawLotto);
    document.getElementById('stickBtn').addEventListener('click', () => resolveThreeDoors(false));
    document.getElementById('switchBtn').addEventListener('click', () => resolveThreeDoors(true));

    // --- Initial Load ---
    window.onload = initializeGame;
    </script>
</body>
</html>
