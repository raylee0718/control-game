<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¦æ…¾æŒ‘æˆ° v6.0</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #1a1a1a;
            --surface-color: #2c2c2c;
            --primary-color: #4a90e2;
            --secondary-color: #50e3c2;
            --text-color: #f0f0f0;
            --text-muted-color: #888;
            --danger-color: #e24a4a;
            --warning-color: #f5a623;
            --success-color: #7ed321;
            --gold-color: #ffd700;
            --font-family: 'Noto Sans TC', sans-serif;
        }

        @keyframes pulse-green {
            0% { text-shadow: 0 0 15px var(--secondary-color); }
            50% { text-shadow: 0 0 25px var(--secondary-color); }
            100% { text-shadow: 0 0 15px var(--secondary-color); }
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 1rem;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }

        .container {
            width: 100%;
            max-width: 850px; /* Increased width for 3 columns */
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .header {
            text-align: center;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 1rem;
        }

        .header h1 {
            margin: 0;
            font-size: 2.5rem;
            color: var(--primary-color);
            text-shadow: 0 0 10px var(--primary-color);
        }

        .timer-display {
            font-size: 4rem;
            font-weight: 700;
            text-align: center;
            color: var(--secondary-color);
            background-color: var(--surface-color);
            padding: 1rem;
            border-radius: 1rem;
            letter-spacing: 0.1em;
            animation: pulse-green 2s infinite;
        }
        
        #buff-area {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: center;
        }
        
        .buff-item {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            width: 80%;
            max-width: 500px;
            text-align: left;
        }
        .buff-item.buff { background-color: rgba(126, 211, 33, 0.2); border: 1px solid var(--success-color); }
        .buff-item.debuff { background-color: rgba(226, 74, 74, 0.15); border: 1px solid var(--danger-color); }

        .buff-header {
            font-weight: bold;
            font-size: 0.9rem;
        }
        .buff-header.buff { color: var(--success-color); }
        .buff-header.debuff { color: var(--danger-color); }

        .buff-description {
            font-size: 0.8rem;
            color: var(--text-color);
        }

        #punishmentArea, #timersArea {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .status-item {
            border-radius: 0.5rem;
            padding: 0.75rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
        }
        .status-item span { font-weight: bold; }
        
        .timer-item { background-color: rgba(245, 166, 35, 0.2); border: 1px solid var(--warning-color); }
        .timer-item span { color: var(--warning-color); }

        .punishment-item { background-color: rgba(226, 74, 74, 0.15); border: 1px solid var(--danger-color); }
        .punishment-item span { color: var(--danger-color); }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
        }
        
        .control-card {
            background-color: var(--surface-color);
            border-radius: 1rem;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem; /* Reduced gap */
            border: 1px solid transparent;
            transition: all 0.3s ease;
        }

        .control-card h3 {
            margin: 0 0 0.5rem 0;
            font-size: 1.5rem;
            color: var(--primary-color);
            text-align: center;
        }
        
        .control-card .charge-info { font-size: 0.8rem; color: var(--text-muted-color); background-color: #333; padding: 0.2rem 0.5rem; border-radius: 0.5rem; }
        .control-card .charge-cooldown { font-size: 0.8rem; color: var(--text-muted-color); margin: 0.5rem 0 0 0; }
        .control-card .description { margin: 0.5rem 0; font-size: 0.9rem; color: var(--text-muted-color); text-align: center; min-height: 2.7em; }
        .charge-count-display { font-size: 0.9rem; color: var(--secondary-color); margin-top: 0.5rem; font-weight: bold; }

        .btn { font-family: var(--font-family); padding: 0.75rem 1.5rem; font-size: 1rem; font-weight: 500; border: none; border-radius: 0.5rem; cursor: pointer; transition: all 0.3s ease; width: 100%; display: flex; justify-content: center; align-items: center; gap: 0.5rem; }
        .btn-primary { background-color: var(--primary-color); color: white; box-shadow: 0 4px 15px -5px var(--primary-color); }
        .btn-primary:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 6px 20px -5px var(--primary-color); }
        .btn-danger { background-color: var(--danger-color); color: white; }
        .btn-warning { background-color: var(--warning-color); color: white; }
        .btn:disabled { background-color: #555; color: #888; cursor: not-allowed; box-shadow: none; }
        
        .dice-area { display: flex; gap: 2rem; margin-top: 0.5rem; padding: 1rem; background-color: #1f1f1f; border-radius: 0.5rem; }
        .dice-container { display: flex; flex-direction: column; align-items: center; gap: 0.5rem; }
        .dice-label { font-size: 1rem; font-weight: 500; color: var(--text-muted-color); }
        .dice { width: 60px; height: 60px; background-color: #fff; border-radius: 10px; display: flex; justify-content: center; align-items: center; color: var(--bg-color); font-weight: bold; box-shadow: 0 2px 5px rgba(0,0,0,0.2); font-size: 3rem; }

        .slot-machine-container { width: 100%; max-width: 300px; height: 80px; background: #111; border-radius: 10px; overflow: hidden; position: relative; border: 3px solid var(--primary-color); box-shadow: inset 0 0 10px rgba(0,0,0,0.5); margin: 0.5rem 0; }
        .slot-reels { position: absolute; top: 0; left: 0; right: 0; transition: top 4s cubic-bezier(0.25, 1, 0.5, 1); }
        .slot-item { height: 80px; display: flex; justify-content: center; align-items: center; font-size: 1.5rem; font-weight: bold; }
        .slot-item.reward { color: var(--success-color); }
        .slot-item.penalty { color: var(--danger-color); }
        .slot-item.special { color: var(--secondary-color); }

        .log-section { background-color: var(--surface-color); border-radius: 1rem; padding: 1rem; }
        .log-section h3 { margin-top: 0; color: var(--primary-color); border-bottom: 1px solid var(--text-muted-color); padding-bottom: 0.5rem; }
        #eventLog { height: 250px; overflow-y: auto; padding-right: 10px; }
        #eventLog p { margin: 0.5rem 0; font-size: 0.875rem; border-bottom: 1px solid #444; padding-bottom: 0.5rem; }
        #eventLog p:last-child { border-bottom: none; }
        
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.85); display: none; justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background-color: var(--surface-color); padding: 1.5rem 2rem; border-radius: 1rem; text-align: center; width: 95%; max-width: 700px; box-shadow: 0 5px 25px rgba(0,0,0,0.5); display: flex; flex-direction: column; gap: 1.5rem; }
        
        #difficultySelection button, #rouletteBets button { margin: 0.5rem; }
        
        /* Roulette Styles */
        #rouletteWheel { position: relative; width: 300px; height: 300px; border-radius: 50%; border: 5px solid var(--gold-color); margin: 1rem auto; transition: transform 6s cubic-bezier(0.2, 0.8, 0.2, 1); }
        .roulette-slice { position: absolute; width: 100%; height: 100%; clip-path: polygon(50% 50%, 50% 0, 75% 0); /* 30 deg slice */ }
        .roulette-slice span { position: absolute; top: 10px; left: 55%; transform: translateX(-50%); font-weight: bold; font-size: 0.9rem; }
        #roulettePointer { position: absolute; top: -25px; left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 15px solid transparent; border-right: 15px solid transparent; border-top: 25px solid var(--gold-color); }

        /* Monopoly Styles */
        #monopolyBoard { display: grid; /* grid-template-columns is set by JS */ gap: 4px; background: #111; padding: 8px; border-radius: 8px; position: relative; }
        .board-cell { width: 100%; padding-top: 100%; position: relative; border-radius: 4px; font-size: 9px; font-weight: bold; color: white; line-height: 1.1; }
        .board-cell-content { position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; justify-content: center; align-items: center; padding: 2px; flex-direction: column; text-align: center;}
        .cell-start { background-color: var(--primary-color); }
        .cell-reward { background-color: var(--success-color); }
        .cell-penalty { background-color: var(--danger-color); }
        .cell-buff { background-color: #3a9a9a; }
        .cell-debuff { background-color: #8b008b; }
        .cell-special { background: linear-gradient(45deg, var(--warning-color), var(--gold-color)); }
        #playerPiece { position: absolute; width: 20px; height: 20px; background-color: var(--secondary-color); border-radius: 50%; border: 2px solid white; transition: all 0.5s ease-in-out; z-index: 5; box-shadow: 0 0 10px var(--secondary-color); }
        #monopolyInfo { display: flex; justify-content: space-around; align-items: center; gap: 1rem; }
        #monopolyEventText { flex: 1; text-align: center; font-weight: bold; }

        /* Lotto Styles */
        #lottoGrid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 0.5rem; margin: 1rem 0; }
        .lotto-number { padding: 0.8rem; border: 1px solid var(--text-muted-color); border-radius: 50%; cursor: pointer; transition: all 0.2s ease; }
        .lotto-number.selected { background-color: var(--primary-color); color: white; border-color: var(--primary-color); }

        /* Three Doors Styles */
        #threeDoorsContainer { display: flex; justify-content: space-around; gap: 1rem; margin: 1rem 0; }
        .door { width: 120px; height: 180px; border: 3px solid var(--gold-color); border-radius: 10px; background-color: #4a2c0f; cursor: pointer; transition: all 0.3s ease; display: flex; justify-content: center; align-items: center; font-size: 4rem; color: var(--gold-color); }
        .door:hover { transform: scale(1.05); }
        .door.selected { border-color: var(--secondary-color); box-shadow: 0 0 20px var(--secondary-color); }
        .door.opened { background-color: #111; cursor: default; }
        .door .door-content { font-size: 1.2rem; font-weight: bold; padding: 0.5rem; text-align: center; }
        #threeDoorsChoices { display: none; gap: 1rem; justify-content: center; }

    </style>
</head>
<body>

    <div class="container">
        <!-- Header and Timer -->
        <header class="header">
            <h1>ğŸŒŸ ç¦æ…¾æŒ‘æˆ° ğŸŒŸ</h1>
        </header>
        <div id="timerDisplay" class="timer-display"><span id="timerText">00:00:00</span></div>
        <div id="buff-area"></div>
        
        <!-- Punishments -->
        <div id="timersArea"></div>
        <div id="punishmentArea"></div>

        <!-- Unlock Section -->
        <div id="unlockSection" style="display: none; text-align: center;">
             <p>ğŸ‰ æ­å–œï¼è¨ˆæ™‚å™¨å·²æ­¸é›¶ï¼ğŸ‰</p>
            <button id="unlockBtn" class="btn btn-secondary btn-lg" style="max-width: 300px; margin: auto;">ğŸ° é€²è¡Œæœ€çµ‚çš„è§£é–è³­æ³¨</button>
        </div>

        <!-- Main Controls -->
        <div class="controls-grid">
            <div id="diceCard" class="control-card">
                <h3>ğŸ² é›™éª°å°æ±º</h3>
                <p class="charge-info">æ¯ 30 åˆ†é˜ç´¯ç© 1 æ¬¡</p>
                <div class="dice-area">
                    <div class="dice-container"><span class="dice-label">ä½ </span><div id="playerDice" class="dice">?</div></div>
                    <div class="dice-container"><span class="dice-label">Bot</span><div id="botDice" class="dice">?</div></div>
                </div>
                <button id="diceBtn" class="btn btn-primary">æ“²éª°</button>
                <p class="charge-count-display">å¯ç”¨æ¬¡æ•¸: <span id="diceCharges">0</span></p>
                <p class="charge-cooldown" id="diceCooldown">ä¸‹æ¬¡ç´¯ç©: ...</p>
            </div>
            
            <div id="slotCard" class="control-card">
                <h3>ğŸ° å‘½é‹æ‹‰éœ¸æ©Ÿ</h3>
                <p class="charge-info">æ¯ 30 åˆ†é˜ç´¯ç© 1 æ¬¡</p>
                <div class="slot-machine-container"><div id="slotReels" class="slot-reels"></div></div>
                <button id="slotBtn" class="btn btn-primary">æ‹‰éœ¸</button>
                <p class="charge-count-display">å¯ç”¨æ¬¡æ•¸: <span id="slotCharges">0</span></p>
                <p class="charge-cooldown" id="slotCooldown">ä¸‹æ¬¡ç´¯ç©: ...</p>
            </div>

            <div id="rouletteCard" class="control-card">
                <h3>ğŸ˜ˆ é­”é¬¼çš„è¼ªç›¤</h3>
                <p class="charge-info">æ¯ 3 å°æ™‚ç´¯ç© 1 æ¬¡</p>
                <p class="description">é«˜é¢¨éšªã€é«˜å›å ±çš„ç­–ç•¥è³­åšã€‚é‡‘è‰²é ­çå¯ä»¥è®“ä½ ç¬é–“æ¸›å°‘24å°æ™‚ï¼</p>
                <button id="rouletteBtn" class="btn btn-primary">éŠç©</button>
                <p class="charge-count-display">å¯ç”¨æ¬¡æ•¸: <span id="rouletteCharges">0</span></p>
                <p class="charge-cooldown" id="rouletteCooldown">ä¸‹æ¬¡ç´¯ç©: ...</p>
            </div>

            <div id="monopolyCard" class="control-card">
                <h3>ğŸ—ºï¸ å‘½é‹æ£‹ç›¤</h3>
                <p class="charge-info">æ¯ 1 å°æ™‚ç´¯ç© 1 æ¬¡</p>
                <p class="description">å•Ÿå‹•é€£é–ç…‰é‡‘é™£ï¼å¼·åŒ–ä½ çš„å…¶ä»–æ“ä½œï¼Œæ‰“å‡ºæ„æƒ³ä¸åˆ°çš„çµ„åˆæŠ€ï¼</p>
                <button id="monopolyBtn" class="btn btn-primary">é€²å…¥</button>
                <p class="charge-count-display">å¯ç”¨æ¬¡æ•¸: <span id="monopolyCharges">0</span></p>
                <p class="charge-cooldown" id="monopolyCooldown">ä¸‹æ¬¡ç´¯ç©: ...</p>
            </div>

            <div id="lottoCard" class="control-card">
                <h3>ğŸŸï¸ å³æ™‚æ™‚é–“å½©</h3>
                <p class="charge-info">æ¯ 3 å°æ™‚ç´¯ç© 1 æ¬¡</p>
                <p class="description">èŠ±è²»30åˆ†é˜æˆæœ¬ï¼Œç«‹å³å°çï¼å°ä¸­5ç¢¼ï¼Œç›´æ¥æ¸›å°‘48å°æ™‚ï¼</p>
                <button id="lottoBtn" class="btn btn-primary">éŠç©</button>
                <p class="charge-count-display">å¯ç”¨æ¬¡æ•¸: <span id="lottoCharges">0</span></p>
                <p class="charge-cooldown" id="lottoCooldown">ä¸‹æ¬¡ç´¯ç©: ...</p>
            </div>
            
            <div id="threeDoorsCard" class="control-card">
                <h3>ğŸšª å‘½é‹ä¸‰é–€</h3>
                <p class="charge-info">æ¯ 4 å°æ™‚ç´¯ç© 1 æ¬¡</p>
                <p class="description">ç¶“å…¸çš„ä¸‰é¸ä¸€å¿ƒç†åšå¼ˆã€‚é–€å¾Œæ˜¯å¤©å ‚é‚„æ˜¯åœ°ç„ï¼Œæ›ä¸æ›é–€ç”±ä½ æ±ºå®šï¼</p>
                <button id="threeDoorsBtn" class="btn btn-primary">éŠç©</button>
                <p class="charge-count-display">å¯ç”¨æ¬¡æ•¸: <span id="threeDoorsCharges">0</span></p>
                <p class="charge-cooldown" id="threeDoorsCooldown">ä¸‹æ¬¡ç´¯ç©: ...</p>
            </div>
        </div>

        <!-- Log -->
        <div class="log-section">
            <h3>ğŸ“œ äº‹ä»¶ç´€éŒ„</h3>
            <div id="eventLog"></div>
        </div>

        <button id="newChallengeBtn" class="btn btn-danger">ğŸŒ± é–‹å•Ÿæ–°æŒ‘æˆ°</button>
    </div>
    
    <!-- Modals -->
    <div id="difficultyModal" class="modal-overlay">
        <div class="modal-content">
            <h2>é¸æ“‡æŒ‘æˆ°é›£åº¦</h2>
            <p>é›£åº¦å°‡ç”Ÿæˆä¸€å€‹ã€Œä¹˜æ•¸ã€ï¼Œå½±éŸ¿æ‰€æœ‰èˆ‡æ™‚é–“ç›¸é—œçš„çæ‡²èˆ‡æˆæœ¬ã€‚</p>
            <div id="difficultySelection">
                <button class="btn btn-primary" data-level="1" data-multiplier="1.0">ç­‰ç´š1 (æ–°æ‰‹ x1.0)</button>
                <button class="btn btn-primary" data-level="2" data-multiplier="1.5">ç­‰ç´š2 (ç†Ÿç·´ x1.5)</button>
                <button class="btn btn-primary" data-level="3" data-multiplier="2.25">ç­‰ç´š3 (ç²¾è‹± x2.25)</button>
                <button class="btn btn-warning" data-level="4" data-multiplier="3.375">ç­‰ç´š4 (å°ˆå®¶ x3.375)</button>
                <button class="btn btn-danger" data-level="5" data-multiplier="5.0625">ç­‰ç´š5 (å‚³èªª x5.0625)</button>
            </div>
        </div>
    </div>
    
    <div id="finalUnlockModal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="finalUnlockTitle"></h2>
            <p id="finalUnlockMessage"></p>
            <button id="finalUnlockCloseBtn" class="btn btn-primary">æˆ‘æ˜ç™½äº†</button>
        </div>
    </div>

    <div id="rouletteModal" class="modal-overlay">
        <div class="modal-content">
            <h2>ğŸ˜ˆ é­”é¬¼çš„è¼ªç›¤</h2>
            <div style="position: relative; width: 300px; margin: 0 auto;">
                <div id="rouletteWheel"></div>
                <div id="roulettePointer"></div>
            </div>
            <p id="rouletteResultText">ä¸‹æ³¨ä¾†æ±ºå®šä½ çš„å‘½é‹ï¼</p>
            <div id="rouletteBets">
                <p><strong>ä¸‹æ³¨æœƒé å…ˆæ”¯ä»˜æ™‚é–“æˆæœ¬ï¼</strong></p>
                <button class="btn btn-secondary" data-bet-type="color" data-bet-value="red">ç©©å¥ä¸‹æ³¨: ç´…è‰² (-15m)</button>
                <button class="btn btn-secondary" data-bet-type="color" data-bet-value="black">ç©©å¥ä¸‹æ³¨: é»‘è‰² (-15m)</button>
                <br>
                <input type="number" id="specificBetInput" placeholder="ç²¾æº–ä¸‹æ³¨æ ¼è™Ÿ (0-11)" min="0" max="11" style="padding: 0.5rem; border-radius: 0.5rem; border: 1px solid #888; background: #333; color: white; width: 200px; margin-right: 10px;">
                <button id="specificBetBtn" class="btn btn-warning">ä¸‹æ³¨ (-30m)</button>
            </div>
            <div>
                <button id="spinRouletteBtn" class="btn btn-primary" style="margin-top: 1rem;">é–‹å§‹è½‰å‹•ï¼</button>
                <button class="btn" onclick="closeModal('rouletteModal')">é›¢é–‹</button>
            </div>
        </div>
    </div>

    <div id="monopolyModal" class="modal-overlay">
        <div class="modal-content">
            <h2>ğŸ—ºï¸ å‘½é‹æ£‹ç›¤</h2>
            <div id="monopolyBoard"><div id="playerPiece"></div></div>
            <div id="monopolyInfo">
                <div id="monopolyDiceResult" class="dice">?</div>
                <button id="monopolyRollBtn" class="btn btn-primary" style="width: auto;">æ“²éª°å‰é€²</button>
                <p id="monopolyEventText">æ“²éª°ä¾†æ±ºå®šä½ çš„å‘½é‹ï¼</p>
            </div>
            <button class="btn" onclick="closeModal('monopolyModal')">é›¢é–‹æ£‹ç›¤</button>
        </div>
    </div>

    <div id="lottoModal" class="modal-overlay">
        <div class="modal-content">
            <h2>ğŸŸï¸ å³æ™‚æ™‚é–“å½©</h2>
            <p>é¸æ“‡ 5 å€‹å¹¸é‹æ•¸å­— (1-30)ã€‚æ¯æ¬¡éŠç©æˆæœ¬ç‚º 30 åˆ†é˜ã€‚</p>
            <div id="lottoGrid"></div>
            <p>å·²é¸è™Ÿç¢¼: <span id="lottoSelectionText"></span></p>
            <p id="lottoResultArea" style="font-weight: bold;"></p>
            <div>
                <button id="drawLottoBtn" class="btn btn-primary" disabled>ç«‹å³é–‹ç (-30m)</button>
                <button class="btn" onclick="closeModal('lottoModal')">é—œé–‰</button>
            </div>
        </div>
    </div>

    <div id="threeDoorsModal" class="modal-overlay">
        <div class="modal-content">
            <h2>ğŸšª å‘½é‹ä¸‰é–€</h2>
            <p id="threeDoorsMessage">é¸æ“‡ä¸€æ‰‡é–€ï¼Œçœ‹çœ‹ä½ çš„å‘½é‹å¦‚ä½•ï¼</p>
            <div id="threeDoorsContainer">
                <div class="door" data-index="0"><span>?</span></div>
                <div class="door" data-index="1"><span>?</span></div>
                <div class="door" data-index="2"><span>?</span></div>
            </div>
            <div id="threeDoorsChoices">
                <button id="stickBtn" class="btn btn-primary">å …æŒé¸æ“‡</button>
                <button id="switchBtn" class="btn btn-secondary">äº¤æ›é¸æ“‡</button>
            </div>
        </div>
    </div>

    <script>
    // --- Full v6.0 Script ---
    
    // --- DOM Elements ---
    const elements = {
        timerText: document.getElementById('timerText'),
        unlockSection: document.getElementById('unlockSection'),
        unlockBtn: document.getElementById('unlockBtn'),
        newChallengeBtn: document.getElementById('newChallengeBtn'),
        eventLog: document.getElementById('eventLog'),
        buffArea: document.getElementById('buff-area'),
        
        diceBtn: document.getElementById('diceBtn'),
        diceChargesSpan: document.getElementById('diceCharges'),
        playerDiceDiv: document.getElementById('playerDice'),
        botDiceDiv: document.getElementById('botDice'),
        diceCooldown: document.getElementById('diceCooldown'),
        
        slotBtn: document.getElementById('slotBtn'),
        slotReels: document.getElementById('slotReels'),
        slotChargesSpan: document.getElementById('slotCharges'),
        slotCooldown: document.getElementById('slotCooldown'),

        rouletteBtn: document.getElementById('rouletteBtn'),
        rouletteChargesSpan: document.getElementById('rouletteCharges'),
        rouletteModal: document.getElementById('rouletteModal'),
        rouletteWheel: document.getElementById('rouletteWheel'),
        rouletteResultText: document.getElementById('rouletteResultText'),
        spinRouletteBtn: document.getElementById('spinRouletteBtn'),
        specificBetBtn: document.getElementById('specificBetBtn'),
        rouletteCooldown: document.getElementById('rouletteCooldown'),

        monopolyBtn: document.getElementById('monopolyBtn'),
        monopolyChargesSpan: document.getElementById('monopolyCharges'),
        monopolyModal: document.getElementById('monopolyModal'),
        monopolyBoard: document.getElementById('monopolyBoard'),
        monopolyRollBtn: document.getElementById('monopolyRollBtn'),
        monopolyDiceResult: document.getElementById('monopolyDiceResult'),
        monopolyEventText: document.getElementById('monopolyEventText'),
        monopolyCooldown: document.getElementById('monopolyCooldown'),

        lottoBtn: document.getElementById('lottoBtn'),
        lottoModal: document.getElementById('lottoModal'),
        lottoGrid: document.getElementById('lottoGrid'),
        lottoSelectionText: document.getElementById('lottoSelectionText'),
        drawLottoBtn: document.getElementById('drawLottoBtn'),
        lottoResultArea: document.getElementById('lottoResultArea'),
        lottoCharges: document.getElementById('lottoCharges'),
        lottoCooldown: document.getElementById('lottoCooldown'),
        
        threeDoorsBtn: document.getElementById('threeDoorsBtn'),
        threeDoorsModal: document.getElementById('threeDoorsModal'),
        threeDoorsContainer: document.getElementById('threeDoorsContainer'),
        threeDoorsMessage: document.getElementById('threeDoorsMessage'),
        threeDoorsChoices: document.getElementById('threeDoorsChoices'),
        threeDoorsCharges: document.getElementById('threeDoorsCharges'),
        threeDoorsCooldown: document.getElementById('threeDoorsCooldown'),
        
        timersArea: document.getElementById('timersArea'),
        punishmentArea: document.getElementById('punishmentArea'),

        difficultyModal: document.getElementById('difficultyModal'),
        difficultySelection: document.getElementById('difficultySelection'),
        finalUnlockModal: document.getElementById('finalUnlockModal'),
        finalUnlockCloseBtn: document.getElementById('finalUnlockCloseBtn'),
    };

    // --- Game State ---
    let gameState = {};
    let timerInterval;
    let monopolyCellCoords = [];
    let lottoSelection = [];
    let threeDoorsState = {};

    const defaultGameState = {
        startTime: null, targetTime: null, totalChallengeTime: 0,
        difficulty: 1, difficultyMultiplier: 1.0,
        chargeTimers: { dice: 0, slot: 0, roulette: 0, monopoly: 0, lotto: 0, threeDoors: 0 },
        diceCharges: 1, slotCharges: 1, rouletteCharges: 1, monopolyCharges: 1, lottoCharges: 1, threeDoorsCharges: 1,
        timers: [], // Generic timer array for chastity, phone detox etc.
        punishments: {}, // { punishment_key: count }
        monopolyPosition: 0, monopolyBoardMap: [],
        activeBuffs: {}, // { buffId: { name, expiry, value } }
        lastSlotResult: null, // { type, value, text }
        eventLog: [],
    };

    // --- Game Data ---
    const intervals = {
        dice: 30 * 60 * 1000, 
        slot: 30 * 60 * 1000,
        roulette: 3 * 60 * 60 * 1000, 
        monopoly: 1 * 60 * 60 * 1000,
        lotto: 3 * 60 * 60 * 1000,
        threeDoors: 4 * 60 * 60 * 1000,
    };
    const diceFaces = ['âš€', 'âš', 'âš‚', 'âšƒ', 'âš„', 'âš…'];
    const slotOutcomes = [
        { text: "-4h", type: 'reward', value: -4 * 3600 }, { text: "-2h", type: 'reward', value: -2 * 3600 },
        { text: "-1h", type: 'reward', value: -1 * 3600 }, { text: "+4h", type: 'penalty', value: 4 * 3600 },
        { text: "+2h", type: 'penalty', value: 2 * 3600 }, { text: "+1h", type: 'penalty', value: 1 * 3600 },
        { text: "è²æ“é–-30m", type: 'special', effect: 'reduce_timer', payload: 'chastity_lock' },
        { text: "æ¶¼å·¾æ‡²ç½°", type: 'special', effect: 'add_punishment', payload: 'towel_punishment' },
        { text: "åˆ®é¬æ³¡æ‡²ç½°", type: 'special', effect: 'add_punishment', payload: 'foam_punishment' },
    ];
    const rouletteOutcomes = [
        { text: "-24h", type: 'reward', value: -24*3600, color: 'gold' }, { text: "+24h", type: 'penalty', value: 24*3600, color: 'black' },
        { text: "-3h", type: 'reward', value: -3*3600, color: 'red' }, { text: "+4h", type: 'penalty', value: 4*3600, color: 'black' },
        { text: "-1h", type: 'reward', value: -1*3600, color: 'red' }, { text: "+2h", type: 'penalty', value: 2*3600, color: 'black' },
        { text: "æ¬Šåˆ©+1", type: 'special', effect: 'all_charges_plus_one', color: 'red' }, { text: "+1h", type: 'penalty', value: 1*3600, color: 'black' },
        { text: "è²æ“é–", type: 'special', effect: 'add_timer', payload: 'chastity_lock' }, { text: "-1h", type: 'reward', value: -1*3600, color: 'red' },
        { text: "æ¶¼å·¾æ‡²ç½°", type: 'special', effect: 'add_punishment', payload: 'towel_punishment' }, { text: "-3h", type: 'reward', value: -3*3600, color: 'red' },
    ];
    const buffDescriptions = {
        'å¼·åŒ–': 'ä¸‹æ¬¡ã€Œé›™éª°å°æ±ºã€å‹åˆ©æ™‚çå‹µç¿»å€ (ä¸€æ¬¡æ€§)ã€‚',
        'é çŸ¥': 'ä¸‹æ¬¡ã€Œå‘½é‹æ‹‰éœ¸æ©Ÿã€çš„çµæœå°‡è¢«é å…ˆæ­ç¤º (ä¸€æ¬¡æ€§)ã€‚',
        'å¹¸é‹': 'ä¸‹æ¬¡ã€Œå‘½é‹æ‹‰éœ¸æ©Ÿã€å°‡ç§»é™¤æ‰€æœ‰è² é¢çµæœ (ä¸€æ¬¡æ€§)ã€‚',
        'åŠ é€Ÿ': 'æ‰€æœ‰æ¬Šåˆ©çš„ç´¯ç©é€Ÿåº¦ x2ã€‚',
        'å …éŸŒ': 'æ‰€æœ‰å¢åŠ çš„æ™‚é–“æ‡²ç½°æ¸›å°‘ 50%ã€‚',
        'å¯Œè¶³': 'ä¸‹æ¬¡é€šéã€Œå‘½é‹æ£‹ç›¤ã€èµ·é»æ™‚çå‹µç¿»å€ (ä¸€æ¬¡æ€§)ã€‚',
        'è™›å¼±': 'ä¸‹æ¬¡ã€Œé›™éª°å°æ±ºã€å¤±æ•—æ™‚æ‡²ç½°ç¿»å€ (ä¸€æ¬¡æ€§)ã€‚',
        'å„é‹': 'ä¸‹æ¬¡ã€Œå‘½é‹æ‹‰éœ¸æ©Ÿã€å°‡ç§»é™¤æ‰€æœ‰æ­£é¢çµæœ (ä¸€æ¬¡æ€§)ã€‚',
        'é²ç·©': 'æ‰€æœ‰æ¬Šåˆ©çš„ç´¯ç©æš«æ™‚åœæ­¢ã€‚',
        'è„†å¼±': 'æ‰€æœ‰å¢åŠ çš„æ™‚é–“æ‡²ç½°å¢åŠ  50%ã€‚',
    };

    // --- Initialization ---
    function initializeGame() {
        loadState();
        renderSlotMachine();
        buildRouletteWheel();
        buildLottoGrid();
        
        if (!gameState.targetTime) {
            timerText.textContent = "00:00:00";
            disableAllControls();
            elements.unlockSection.style.display = 'none';
            elements.newChallengeBtn.style.display = 'block';
        } else {
            startTimer();
            elements.newChallengeBtn.style.display = 'none';
            if (gameState.monopolyBoardMap.length > 0) renderMonopolyBoard();
        }
        updateUI();
    }

    // --- Core Game Loop & UI Updates ---
    function startNewChallenge(level, multiplier) {
        elements.difficultyModal.style.display = 'none';
        const initialHours = Math.random() * 12 + 12; // Random 12-24 hours
        const initialDuration = Math.floor(initialHours * 3600 * 1000 * multiplier); // Multiplied by difficulty
        const now = Date.now();
        
        gameState = JSON.parse(JSON.stringify(defaultGameState));
        gameState.difficulty = level;
        gameState.difficultyMultiplier = multiplier;
        gameState.startTime = now;
        gameState.targetTime = now + initialDuration;
        gameState.totalChallengeTime = initialDuration;
        
        // Setup initial charge timers
        gameState.chargeTimers = {
            dice: now + intervals.dice,
            slot: now + intervals.slot,
            roulette: now + intervals.roulette,
            monopoly: now + intervals.monopoly,
            lotto: now + intervals.lotto,
            threeDoors: now + intervals.threeDoors,
        };
        
        generateMonopolyBoard();
        renderMonopolyBoard();

        logEvent(`ğŸŒ± ç­‰ç´š ${level} (x${multiplier}) æŒ‘æˆ°é–‹å§‹ï¼åˆå§‹æ™‚é•·ï¼š${formatDuration(initialDuration / 1000)}ã€‚`);
        saveState();
        startTimer();
        elements.newChallengeBtn.style.display = 'none';
        elements.unlockSection.style.display = 'none';
        updateUI();
    }

    function startTimer() {
        if (timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(update, 1000);
    }

    function update() {
        if (!gameState.targetTime) {
            clearInterval(timerInterval);
            timerInterval = null;
            return;
        }

        const now = Date.now();
        let remaining = Math.round((gameState.targetTime - now) / 1000);

        if (remaining <= 0) {
            elements.timerText.textContent = "00:00:00";
            if(timerInterval) clearInterval(timerInterval);
            timerInterval = null;
            gameState.targetTime = null; 
            saveState();
            elements.unlockSection.style.display = 'block';
            elements.unlockBtn.disabled = false;
            disableAllControls();
        } else {
            updateCharges();
            updateBuffs();
            updateAllTimers();
        }
        
        updateTimerDisplay();
        updateButtonStates();
        updateCooldownDisplays();
    }
    
    function updateCharges() {
        const now = Date.now();
        const buff = getActiveBuff('é²ç·©');
        if (buff) {
            const timeToAdd = now - (gameState.lastChargeCalcTime || now);
            Object.keys(gameState.chargeTimers).forEach(key => {
                gameState.chargeTimers[key] += timeToAdd;
            });
            gameState.lastChargeCalcTime = now;
            return;
        }
        
        let stateChanged = false;
        const speedMultiplier = getActiveBuff('åŠ é€Ÿ') ? 2 : 1;

        Object.keys(gameState.chargeTimers).forEach(key => {
            const interval = intervals[key] / speedMultiplier;
            if (now >= gameState.chargeTimers[key]) {
                const chargesToAdd = Math.floor((now - gameState.chargeTimers[key]) / interval) + 1;
                gameState[key + 'Charges'] += chargesToAdd;
                gameState.chargeTimers[key] += chargesToAdd * interval;
                stateChanged = true;
            }
        });
        
        gameState.lastChargeCalcTime = now;
        if (stateChanged) saveState();
    }
    
    function updateCooldownDisplays() {
        const now = Date.now();
        const buff = getActiveBuff('é²ç·©');
        
        Object.keys(elements).forEach(key => {
            if (key.endsWith('Cooldown')) {
                const feature = key.replace('Cooldown', '');
                if (gameState.chargeTimers && gameState.chargeTimers[feature] !== undefined) {
                    if (buff) {
                        elements[key].textContent = 'ä¸‹æ¬¡ç´¯ç©: æš«åœä¸­';
                    } else {
                        const remaining = Math.max(0, gameState.chargeTimers[feature] - now);
                        elements[key].textContent = `ä¸‹æ¬¡ç´¯ç©: ${formatDuration(remaining / 1000)}`;
                    }
                }
            }
        });
    }

    function updateBuffs() {
        const now = Date.now();
        let changed = false;
        for (const id in gameState.activeBuffs) {
            if (now > gameState.activeBuffs[id].expiry) {
                logEvent(`âœ¨ æ•ˆæœçµæŸï¼š[${gameState.activeBuffs[id].name}]`);
                delete gameState.activeBuffs[id];
                changed = true;
            }
        }
        if (changed) {
            renderBuffs();
            saveState();
        }
    }

    function updateUI() {
        updateTimerDisplay();
        updateButtonStates();
        updateCooldownDisplays();
        renderLog();
        renderBuffs();
        renderAllTimers();
        renderPunishments();
    }
    
    function updateButtonStates() {
        elements.diceChargesSpan.textContent = gameState.diceCharges;
        elements.diceBtn.disabled = gameState.diceCharges <= 0;
        elements.slotChargesSpan.textContent = gameState.slotCharges;
        elements.slotBtn.disabled = gameState.slotCharges <= 0;
        elements.rouletteChargesSpan.textContent = gameState.rouletteCharges;
        elements.rouletteBtn.disabled = gameState.rouletteCharges <= 0;
        elements.monopolyChargesSpan.textContent = gameState.monopolyCharges;
        elements.monopolyBtn.disabled = gameState.monopolyCharges <= 0;
        elements.lottoCharges.textContent = gameState.lottoCharges;
        elements.lottoBtn.disabled = gameState.lottoCharges <= 0;
        elements.threeDoorsCharges.textContent = gameState.threeDoorsCharges;
        elements.threeDoorsBtn.disabled = gameState.threeDoorsCharges <= 0;
    }

    function disableAllControls() {
        elements.diceBtn.disabled = true;
        elements.slotBtn.disabled = true;
        elements.rouletteBtn.disabled = true;
        elements.monopolyBtn.disabled = true;
        elements.lottoBtn.disabled = true;
        elements.threeDoorsBtn.disabled = true;
    }

    // --- Utility Functions ---
    function formatDuration(totalSeconds) {
        if (totalSeconds < 0) totalSeconds = 0;
        const h = String(Math.floor(totalSeconds / 3600)).padStart(2, '0');
        const m = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2, '0');
        const s = String(Math.floor(totalSeconds % 60)).padStart(2, '0');
        return `${h}:${m}:${s}`;
    }

    function logEvent(message) {
        const timestamp = new Date().toLocaleString('zh-TW', { hour12: false });
        const fullMessage = `[${timestamp}] ${message}`;
        gameState.eventLog.unshift(fullMessage);
        if (gameState.eventLog.length > 100) gameState.eventLog.pop();
        renderLog();
    }
    
    function saveState() {
        localStorage.setItem('abstinenceGameState_v6.6', JSON.stringify(gameState));
    }

    function loadState() {
        const savedState = localStorage.getItem('abstinenceGameState_v6.6');
        if (savedState) {
            const parsedState = JSON.parse(savedState);
            gameState = { ...defaultGameState, ...parsedState };
            gameState.activeBuffs = parsedState.activeBuffs || {};
            gameState.chargeTimers = parsedState.chargeTimers || { dice: 0, slot: 0, roulette: 0, monopoly: 0, lotto: 0, threeDoors: 0 };
            gameState.timers = parsedState.timers || [];
            gameState.punishments = parsedState.punishments || {};
        } else {
            gameState = JSON.parse(JSON.stringify(defaultGameState));
        }
    }

    function modifyTime(seconds, useMultiplier = true) {
        let multiplier = useMultiplier ? gameState.difficultyMultiplier : 1;
        
        const toughBuff = getActiveBuff('å …éŸŒ');
        const fragileBuff = getActiveBuff('è„†å¼±');
        if (seconds > 0 && toughBuff) multiplier *= 0.5;
        if (seconds > 0 && fragileBuff) multiplier *= 1.5;

        const finalSeconds = Math.round(seconds * multiplier);
        if (!gameState.targetTime) gameState.targetTime = Date.now();
        gameState.targetTime += finalSeconds * 1000;

        const msg = finalSeconds > 0 ? `å¢åŠ  ${formatDuration(Math.abs(finalSeconds))}` : `æ¸›å°‘ ${formatDuration(Math.abs(finalSeconds))}`;
        logEvent(`â±ï¸ æ™‚é–“è®Šå‹•ï¼š${msg}ã€‚`);
        updateTimerDisplay();
        saveState();
    }
    
    function getActiveBuff(name) {
        for (const id in gameState.activeBuffs) {
            if (gameState.activeBuffs[id].name === name) return gameState.activeBuffs[id];
        }
        return null;
    }

    function addBuff(name, durationMinutes, value = null) {
        const id = Date.now();
        const expiry = id + durationMinutes * 60 * 1000;
        gameState.activeBuffs[id] = { name, expiry, value };
        logEvent(`ğŸŸ© æ–°å¢æ•ˆæœï¼š[${name}]ï¼ŒæŒçºŒ ${durationMinutes} åˆ†é˜ï¼`);
        renderBuffs();
    }
    
    function renderBuffs() {
        elements.buffArea.innerHTML = '';
        for (const id in gameState.activeBuffs) {
            const buff = gameState.activeBuffs[id];
            const isDebuff = ['è™›å¼±', 'å„é‹', 'é²ç·©', 'è„†å¼±'].includes(buff.name);
            const remaining = Math.ceil((buff.expiry - Date.now()) / 60000);
            
            const el = document.createElement('div');
            el.className = `buff-item ${isDebuff ? 'debuff' : 'buff'}`;
            
            const header = document.createElement('div');
            header.className = `buff-header ${isDebuff ? 'debuff' : 'buff'}`;
            const durationText = buff.value === true ? '(ä¸€æ¬¡æ€§)' : `(å‰©é¤˜ ${remaining}m)`;
            header.textContent = `[${buff.name}] ${durationText}`;
            
            const description = document.createElement('div');
            description.className = 'buff-description';
            description.textContent = buffDescriptions[buff.name] || 'æœªçŸ¥æ•ˆæœ';
            
            el.appendChild(header);
            el.appendChild(description);
            
            elements.buffArea.appendChild(el);
        }
    }

    function openModal(modalId) { document.getElementById(modalId).style.display = 'flex'; }
    function closeModal(modalId) { document.getElementById(modalId).style.display = 'none'; }
    
    // --- Render Functions ---
    function renderLog() { elements.eventLog.innerHTML = gameState.eventLog.map(msg => `<p>${msg}</p>`).join(''); }
    function updateTimerDisplay() {
        const remaining = gameState.targetTime ? Math.round((gameState.targetTime - Date.now()) / 1000) : 0;
        elements.timerText.textContent = formatDuration(Math.max(0, remaining));
    }
    function renderSlotMachine() {
        elements.slotReels.innerHTML = '';
        const reelItems = [...slotOutcomes, ...slotOutcomes, ...slotOutcomes];
        reelItems.forEach(item => {
            const itemEl = document.createElement('div');
            itemEl.className = `slot-item ${item.type}`;
            itemEl.textContent = item.text;
            elements.slotReels.appendChild(itemEl);
        });
    }

    // --- Feature Implementations ---

    // 1. Dice Duel
    function rollDice() {
        if (gameState.diceCharges <= 0) return;
        gameState.diceCharges--;

        const playerRoll1 = Math.floor(Math.random() * 6) + 1;
        const playerRoll2 = Math.floor(Math.random() * 6) + 1;
        const botRoll1 = Math.floor(Math.random() * 6) + 1;
        const botRoll2 = Math.floor(Math.random() * 6) + 1;
        let playerSum = playerRoll1 + playerRoll2;
        let botSum = botRoll1 + botRoll2;

        elements.playerDiceDiv.textContent = playerSum;
        elements.botDiceDiv.textContent = botSum;
        
        let difference = playerSum - botSum;
        let timeChangeSeconds = difference * -30 * 60;
        
        const strengthenBuff = getActiveBuff('å¼·åŒ–');
        const weakenBuff = getActiveBuff('è™›å¼±');
        
        logEvent(`ğŸ² é›™éª°å°æ±ºï¼šä½ æ“²å‡º ${playerSum} é»ï¼ŒBotæ“²å‡º ${botSum} é»ã€‚`);
        
        if (timeChangeSeconds < 0 && strengthenBuff) {
            timeChangeSeconds *= 2;
            logEvent(`ğŸ’ª[å¼·åŒ–]æ•ˆæœè§¸ç™¼ï¼Œçå‹µç¿»å€ï¼`);
            delete gameState.activeBuffs[Object.keys(strengthenBuff)[0]]; // Consume buff
        }
        if (timeChangeSeconds > 0 && weakenBuff) {
            timeChangeSeconds *= 2;
            logEvent(`ğŸ’€[è™›å¼±]æ•ˆæœè§¸ç™¼ï¼Œæ‡²ç½°ç¿»å€ï¼`);
            delete gameState.activeBuffs[Object.keys(weakenBuff)[0]]; // Consume buff
        }

        if (timeChangeSeconds !== 0) {
             modifyTime(timeChangeSeconds);
        } else {
            logEvent(`ğŸ² å¹³æ‰‹ï¼`);
        }
        
        updateUI();
        saveState();
    }

    // 2. Slot Machine
    function pullSlotMachine() {
        if (gameState.slotCharges <= 0) return;
        gameState.slotCharges--;
        elements.slotBtn.disabled = true;

        let currentPool = [...slotOutcomes];
        const luckyBuff = getActiveBuff('å¹¸é‹');
        const unluckyBuff = getActiveBuff('å„é‹');
        const foresightBuff = getActiveBuff('é çŸ¥');
        
        if (luckyBuff) {
            currentPool = currentPool.filter(o => o.type !== 'penalty');
            logEvent('ğŸ€[å¹¸é‹]æ•ˆæœè§¸ç™¼ï¼Œç§»é™¤äº†æ‰€æœ‰è² é¢äº‹ä»¶ï¼');
            delete gameState.activeBuffs[Object.keys(luckyBuff)[0]];
        }
        if (unluckyBuff) {
            currentPool = currentPool.filter(o => o.type !== 'reward');
            logEvent('ğŸ˜ˆ[å„é‹]æ•ˆæœè§¸ç™¼ï¼Œç§»é™¤äº†æ‰€æœ‰æ­£é¢äº‹ä»¶ï¼');
            delete gameState.activeBuffs[Object.keys(unluckyBuff)[0]];
        }

        const outcome = currentPool[Math.floor(Math.random() * currentPool.length)];
        
        if (foresightBuff) {
            logEvent(`ğŸ‘ï¸[é çŸ¥]æ•ˆæœè§¸ç™¼ï¼Œä½ çŸ¥é“äº†çµæœæ˜¯ã€Œ${outcome.text}ã€ï¼`);
            delete gameState.activeBuffs[Object.keys(foresightBuff)[0]];
        }
        
        const visualIndex = slotOutcomes.indexOf(outcome);
        const basePosition = slotOutcomes.length * 80;
        const targetPosition = basePosition + (visualIndex * 80);
        
        elements.slotReels.style.transition = 'none';
        elements.slotReels.style.top = '0px';

        setTimeout(() => {
            elements.slotReels.style.transition = 'top 4s cubic-bezier(0.25, 1, 0.5, 1)';
            elements.slotReels.style.top = `-${targetPosition}px`;
        }, 50);

        setTimeout(() => {
            logEvent(`ğŸ° å‘½é‹æ‹‰éœ¸æ©Ÿï¼šè½‰åˆ°ã€Œ${outcome.text}ã€ã€‚`);
            gameState.lastSlotResult = outcome;
            if (outcome.value) {
                modifyTime(outcome.value);
            } else if (outcome.effect) {
                handleSpecialOutcome(outcome.effect, outcome.payload);
            }
            updateUI();
            saveState();
        }, 4100);
    }

    // 3. Roulette
    function buildRouletteWheel() {
        elements.rouletteWheel.innerHTML = '';
        rouletteOutcomes.forEach((slice, i) => {
            const sliceEl = document.createElement('div');
            sliceEl.className = 'roulette-slice';
            const rotation = i * 30; // 360 / 12 slices
            let bgColor = slice.color === 'red' ? '#B22222' : '#1C1C1C';
            if (slice.color === 'gold') bgColor = 'gold';
            sliceEl.style.transform = `rotate(${rotation}deg)`;
            sliceEl.style.backgroundColor = bgColor;
            sliceEl.innerHTML = `<span style="color: ${slice.color === 'black' ? 'white' : 'black'}; transform: rotate(-${rotation+15}deg);">${slice.text}</span>`;
            elements.rouletteWheel.appendChild(sliceEl);
        });
    }

    let currentBet = null;
    function setupRoulette() {
        if (gameState.rouletteCharges <= 0) return;
        currentBet = null;
        elements.rouletteResultText.textContent = 'ä¸‹æ³¨ä¾†æ±ºå®šä½ çš„å‘½é‹ï¼';
        elements.spinRouletteBtn.disabled = false;
        elements.rouletteWheel.style.transition = 'none';
        elements.rouletteWheel.style.transform = 'rotate(0deg)';
        openModal('rouletteModal');
    }

    function placeRouletteBet(type, value) {
        const cost = type === 'color' ? 15*60 : 30*60;
        modifyTime(cost);
        currentBet = { type, value };
        logEvent(`ğŸ² è¼ªç›¤ä¸‹æ³¨ï¼š${type === 'color' ? 'é¡è‰²' : 'è™Ÿç¢¼'} ${value}ï¼ŒèŠ±è²» ${cost/60} åˆ†é˜ã€‚`);
    }

    function spinRoulette() {
        if (gameState.rouletteCharges <= 0) return;
        gameState.rouletteCharges--;
        elements.spinRouletteBtn.disabled = true;

        const randomIndex = Math.floor(Math.random() * rouletteOutcomes.length);
        const outcome = rouletteOutcomes[randomIndex];
        
        const degrees = 360 * 5 + (360 - randomIndex * 30) - 15; // Spin 5 times + land on slice
        elements.rouletteWheel.style.transition = 'transform 6s cubic-bezier(0.2, 0.8, 0.2, 1)';
        elements.rouletteWheel.style.transform = `rotate(${degrees}deg)`;
        
        setTimeout(() => {
            elements.rouletteResultText.textContent = `çµæœæ˜¯ï¼š${outcome.text}!`;
            logEvent(`ğŸ˜ˆ é­”é¬¼çš„è¼ªç›¤çµæœï¼š${outcome.text}ï¼`);
            let finalValue = outcome.value || 0;

            // Check bet
            if (currentBet) {
                let win = false;
                if (currentBet.type === 'color' && currentBet.value === outcome.color) win = true;
                if (currentBet.type === 'specific' && currentBet.value == randomIndex) win = true; // Use == for type coercion

                if (win && finalValue < 0) {
                    const multiplier = currentBet.type === 'color' ? 2 : 3;
                    finalValue *= multiplier;
                    logEvent(`ğŸ’° ä¸‹æ³¨æˆåŠŸï¼çå‹µè®Šç‚º ${multiplier} å€ï¼`);
                } else if (win) {
                    logEvent(`ğŸ’° ä¸‹æ³¨æˆåŠŸï¼ä½†çµæœä¸æ˜¯æ™‚é–“çå‹µã€‚`);
                } else {
                    logEvent(`ğŸ’¸ ä¸‹æ³¨å¤±æ•—ã€‚`);
                }
            }

            if (finalValue !== 0) modifyTime(finalValue);
            if (outcome.effect) handleSpecialOutcome(outcome.effect, outcome.payload);
            
            updateUI();
            saveState();
        }, 6100);
    }
    
    // 4. Monopoly
    function generateMonopolyBoard() {
        // Fixed board layout based on the user-provided image
        const boardLayout = [
            { type: 'start', text: 'èµ·é» (-3h)', value: -3 * 3600 }, // 0
            { type: 'penalty', text: '+2h', value: 2 * 3600 }, // 1
            { type: 'reward', text: '-1h', value: -1 * 3600 }, // 2
            { type: 'buff', text: 'å¹¸é‹', effect: 'å¹¸é‹', duration: 0 }, // 3
            { type: 'debuff', text: 'å„é‹', effect: 'å„é‹', duration: 0 }, // 4
            { type: 'special', text: 'ç§»é™¤è²æ“é–', effect: 'remove_timer', payload: 'chastity_lock' }, // 5
            { type: 'penalty', text: '+3h', value: 3 * 3600 }, // 6
            { type: 'buff', text: 'å¼·åŒ–', effect: 'å¼·åŒ–', duration: 0 }, // 7
            { type: 'debuff', text: 'è™›å¼±', effect: 'è™›å¼±', duration: 0 }, // 8
            { type: 'special', text: 'æ¶¼å·¾æ‡²ç½°', effect: 'add_punishment', payload: 'towel_punishment' }, // 9
            { type: 'penalty', text: '+3h', value: 3 * 3600 }, // 10
            { type: 'buff', text: 'å …éŸŒ', effect: 'å …éŸŒ', duration: 30 }, // 11 ("å …å®š" in image)
            { type: 'debuff', text: 'è„†å¼±', effect: 'è„†å¼±', duration: 30 }, // 12
            { type: 'penalty', text: '+2h', value: 2 * 3600 }, // 13
            { type: 'reward', text: '-2h', value: -2 * 3600 }, // 14
            { type: 'buff', text: 'å¯Œè¶³', effect: 'å¯Œè¶³', duration: 0 }, // 15
            { type: 'special', text: 'è²æ“é–', effect: 'add_timer', payload: 'chastity_lock' }, // 16
            { type: 'reward', text: '-4h', value: -4 * 3600 }, // 17
            { type: 'special', text: 'è¤‡è£½æ‹‰éœ¸(è² )', effect: 'copy_slot_negative' }, // 18
            { type: 'reward', text: '-1h', value: -1 * 3600 }, // 19
            { type: 'reward', text: '-3h', value: -3 * 3600 }, // 20
            { type: 'special', text: 'åˆ®é¬æ³¡æ‡²ç½°', effect: 'add_punishment', payload: 'foam_punishment' }, // 21
            { type: 'penalty', text: '+4h', value: 4 * 3600 }, // 22
            { type: 'special', text: 'è²æ“é–', effect: 'add_timer', payload: 'chastity_lock' }, // 23
            { type: 'reward', text: '-1h', value: -1 * 3600 }, // 24
            { type: 'special', text: 'æ¬Šåˆ©+1', effect: 'all_charges_plus_one' }, // 25
            { type: 'reward', text: '-2h', value: -2 * 3600 }, // 26
            { type: 'reward', text: '-3h', value: -3 * 3600 }, // 27
            { type: 'buff', text: 'åŠ é€Ÿ', effect: 'åŠ é€Ÿ', duration: 60 }, // 28
            { type: 'special', text: 'æ¬Šåˆ©+1', effect: 'all_charges_plus_one' }, // 29
            { type: 'reward', text: '-1h', value: -1 * 3600 }, // 30
            { type: 'buff', text: 'é çŸ¥', effect: 'é çŸ¥', duration: 0 }, // 31
            { type: 'reward', text: '-2h', value: -2 * 3600 }, // 32
            { type: 'buff', text: 'å …éŸŒ', effect: 'å …éŸŒ', duration: 30 }, // 33
            { type: 'penalty', text: '+2h', value: 2 * 3600 }, // 34
            { type: 'penalty', text: '+2h', value: 2 * 3600 }, // 35
        ];
        gameState.monopolyBoardMap = boardLayout;
    }
    
    function renderMonopolyBoard() {
        const board = elements.monopolyBoard;
        board.innerHTML = '';
        monopolyCellCoords = [];
        const size = 10; // 10x10 grid for this layout
        
        // Hardcode the path based on the image
        // Top row (0-9)
        for (let i = 0; i < 10; i++) monopolyCellCoords.push({ y: 0, x: i });
        // Right col (10-18)
        for (let i = 1; i < 10; i++) monopolyCellCoords.push({ y: i, x: 9 });
        // Bottom row (19-27)
        for (let i = 8; i >= 0; i--) monopolyCellCoords.push({ y: 9, x: i });
        // Left col (28-35)
        for (let i = 8; i >= 1; i--) monopolyCellCoords.push({ y: i, x: 0 });

        // Change grid layout to 10x10
        board.style.gridTemplateColumns = `repeat(${size}, 1fr)`;

        let grid = Array(size).fill(null).map(() => Array(size).fill(null));
        monopolyCellCoords.forEach((coord, index) => {
            if (grid[coord.y] && grid[coord.y][coord.x] === null) {
                grid[coord.y][coord.x] = { ...gameState.monopolyBoardMap[index], index };
            }
        });

        for (let r = 0; r < size; r++) {
            for (let c = 0; c < size; c++) {
                const cellEl = document.createElement('div');
                if (grid[r][c]) {
                    const cellData = grid[r][c];
                    cellEl.className = `board-cell cell-${cellData.type}`;
                    cellEl.innerHTML = `<div class="board-cell-content"><span>${cellData.index}</span><span>${cellData.text}</span></div>`;
                }
                board.appendChild(cellEl);
            }
        }
        board.innerHTML += '<div id="playerPiece"></div>';
        updatePlayerPiecePosition();
    }


    function updatePlayerPiecePosition() {
        const playerPieceEl = document.getElementById('playerPiece');
        if (!playerPieceEl || monopolyCellCoords.length === 0) return;
        const {x, y} = monopolyCellCoords[gameState.monopolyPosition];
        const cellWidth = elements.monopolyBoard.firstChild.offsetWidth;
        playerPieceEl.style.top = `${y * (cellWidth + 4) + cellWidth/2 - playerPieceEl.offsetHeight/2}px`;
        playerPieceEl.style.left = `${x * (cellWidth + 4) + cellWidth/2 - playerPieceEl.offsetWidth/2}px`;
    }

    function setupMonopoly() {
        if (gameState.monopolyCharges <= 0) return;
        elements.monopolyEventText.textContent = "æ“²éª°ä¾†æ±ºå®šä½ çš„å‘½é‹ï¼";
        elements.monopolyDiceResult.textContent = "?";
        openModal('monopolyModal');
        updatePlayerPiecePosition();
    }

    function rollMonopolyDice() {
        if (gameState.monopolyCharges <= 0) return;
        gameState.monopolyCharges--;
        elements.monopolyRollBtn.disabled = true;

        const roll = Math.floor(Math.random() * 6) + 1;
        elements.monopolyDiceResult.textContent = diceFaces[roll - 1];
        
        const oldPosition = gameState.monopolyPosition;
        const newPosition = (oldPosition + roll) % gameState.monopolyBoardMap.length;
        
        // Animate movement
        let currentDisplayPos = oldPosition;
        const moveInterval = setInterval(() => {
            currentDisplayPos = (currentDisplayPos + 1) % gameState.monopolyBoardMap.length;
            gameState.monopolyPosition = currentDisplayPos;
            updatePlayerPiecePosition();
            if (currentDisplayPos === newPosition) {
                clearInterval(moveInterval);
                // Landed, now trigger events
                gameState.monopolyPosition = newPosition;
                if (newPosition < oldPosition) {
                    let reward = -3 * 3600;
                    if (getActiveBuff('å¯Œè¶³')) {
                        reward *= 2;
                        logEvent('ğŸ’°[å¯Œè¶³]æ•ˆæœè§¸ç™¼ï¼Œé€šéèµ·é»çå‹µç¿»å€ï¼');
                        delete gameState.activeBuffs[Object.keys(getActiveBuff('å¯Œè¶³'))[0]];
                    }
                    logEvent('ğŸ‰ æ­å–œï¼ä½ å®Œæˆäº†å‘½é‹æ£‹ç›¤ä¸€åœˆï¼');
                    modifyTime(reward);
                }
                handleMonopolyLand();
                elements.monopolyRollBtn.disabled = false;
            }
        }, 200);
    }
    
    function handleMonopolyLand() {
        const landedCell = gameState.monopolyBoardMap[gameState.monopolyPosition];
        elements.monopolyEventText.textContent = `ç¬¬${gameState.monopolyPosition}æ ¼: ${landedCell.text}`;
        logEvent(`ğŸ—ºï¸ å‘½é‹æ£‹ç›¤ï¼šä¾†åˆ°ç¬¬ ${gameState.monopolyPosition} æ ¼ï¼Œè§¸ç™¼ã€Œ${landedCell.text}ã€ï¼`);

        if (landedCell.value) modifyTime(landedCell.value);
        if (landedCell.effect) {
            if (landedCell.duration > 0) {
                addBuff(landedCell.effect, landedCell.duration);
            } else {
                handleSpecialOutcome(landedCell.effect, landedCell.payload);
            }
        }
        if (landedCell.type === 'start') modifyTime(-3*3600);
        
        updateUI();
        saveState();
    }

    // 5. Instant Lotto
    function buildLottoGrid() {
        elements.lottoGrid.innerHTML = '';
        for (let i = 1; i <= 30; i++) {
            const numEl = document.createElement('div');
            numEl.className = 'lotto-number';
            numEl.textContent = i;
            numEl.dataset.number = i;
            numEl.addEventListener('click', () => toggleLottoNumber(i, numEl));
            elements.lottoGrid.appendChild(numEl);
        }
    }
    
    function setupLotto() {
        if (gameState.lottoCharges <= 0) return;
        lottoSelection = [];
        updateLottoSelectionUI();
        elements.lottoResultArea.textContent = '';
        openModal('lottoModal');
    }
    
    function toggleLottoNumber(num, el) {
        const index = lottoSelection.indexOf(num);
        if (index > -1) {
            lottoSelection.splice(index, 1);
        } else if (lottoSelection.length < 5) {
            lottoSelection.push(num);
        }
        updateLottoSelectionUI();
    }
    
    function updateLottoSelectionUI() {
        lottoSelection.sort((a, b) => a - b);
        elements.lottoSelectionText.textContent = lottoSelection.join(', ') || 'å°šæœªé¸æ“‡';
        document.querySelectorAll('.lotto-number').forEach(el => {
            el.classList.toggle('selected', lottoSelection.includes(parseInt(el.dataset.number)));
        });
        elements.drawLottoBtn.disabled = lottoSelection.length !== 5;
    }

    function drawLotto() {
        if (lottoSelection.length !== 5 || gameState.lottoCharges <= 0) return;
        
        gameState.lottoCharges--;
        modifyTime(30 * 60); // Cost
        logEvent(`ğŸŸï¸ è³¼è²·äº†ä¸€å¼µå³æ™‚å½©åˆ¸ï¼Œè™Ÿç¢¼ç‚ºï¼š${lottoSelection.join(', ')}`);
        
        const winningNumbers = new Set();
        while (winningNumbers.size < 5) {
            winningNumbers.add(Math.floor(Math.random() * 30) + 1);
        }
        const winningArray = [...winningNumbers].sort((a,b) => a-b);
        
        const matches = lottoSelection.filter(num => winningNumbers.has(num)).length;
        let reward = 0;
        let rewardText = `é–‹çè™Ÿç¢¼: ${winningArray.join(', ')}. ä½ çš„è™Ÿç¢¼: ${lottoSelection.join(', ')}. å°ä¸­ ${matches} ç¢¼`;

        if (matches === 5) { reward = -48 * 3600; rewardText += 'ï¼Œä¸­äº†é ­çï¼'; }
        else if (matches === 4) { reward = -12 * 3600; rewardText += 'ï¼Œä¸­äº†äºŒçï¼'; }
        else if (matches === 3) { reward = -4 * 3600; rewardText += 'ï¼Œä¸­äº†ä¸‰çï¼'; }
        else if (matches === 2) { reward = -30 * 60; rewardText += 'ï¼Œä¸­äº†æ™®çï¼Œè¿”é‚„æˆæœ¬ã€‚'; }
        else { rewardText += 'ï¼Œæœªä¸­çã€‚'; }
        
        elements.lottoResultArea.textContent = rewardText;
        logEvent(`ğŸŸï¸ å³æ™‚é–‹ççµæœï¼š${rewardText}`);

        if (reward !== 0) modifyTime(reward);
        
        lottoSelection = [];
        updateLottoSelectionUI();
        updateUI();
        saveState();
    }

    // 6. Three Doors of Fate
    function setupThreeDoors() {
        if (gameState.threeDoorsCharges <= 0) return;
        gameState.threeDoorsCharges--;
        
        const [prize, trap1, trap2] = generateThreeDoorsSet();
        let doors = [prize, trap1, trap2];
        for (let i = doors.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [doors[i], doors[j]] = [doors[j], doors[i]];
        }

        threeDoorsState = {
            doors: doors,
            playerChoice: null,
            openedByHost: null,
            step: 1, // 1 for initial choice, 2 for switch/stick decision
        };

        elements.threeDoorsMessage.innerHTML = `æœ¬å›åˆçå‹µï¼š<strong style="color: var(--success-color);">${prize.text}</strong><br>é™·é˜±ï¼š<strong style="color: var(--danger-color);">${trap1.text}</strong>ã€<strong style="color: var(--danger-color);">${trap2.text}</strong><br>è«‹é¸æ“‡ä¸€æ‰‡é–€ï¼`;
        elements.threeDoorsChoices.style.display = 'none';
        document.querySelectorAll('.door').forEach((door, i) => {
            door.classList.remove('selected', 'opened');
            door.innerHTML = '<span>?</span>';
            door.onclick = () => chooseDoor(i);
        });

        openModal('threeDoorsModal');
    }

    function chooseDoor(index) {
        if (threeDoorsState.step !== 1) return;
        threeDoorsState.playerChoice = index;
        threeDoorsState.step = 2;

        document.querySelectorAll('.door').forEach((door, i) => {
            door.classList.toggle('selected', i === index);
            door.onclick = null; // Disable further clicks
        });

        let doorToOpen;
        for (let i = 0; i < 3; i++) {
            if (i !== threeDoorsState.playerChoice && !threeDoorsState.doors[i].isPrize) {
                doorToOpen = i;
                break;
            }
        }
        
        threeDoorsState.openedByHost = doorToOpen;

        setTimeout(() => {
            const openedDoorEl = document.querySelector(`.door[data-index="${doorToOpen}"]`);
            openedDoorEl.classList.add('opened');
            openedDoorEl.innerHTML = `<div class="door-content">${threeDoorsState.doors[doorToOpen].text}</div>`;
            
            elements.threeDoorsMessage.textContent = `ä¸»æŒäººæ‰“é–‹äº†ä¸€æ‰‡æ‡²ç½°é–€... ä½ ç¢ºå®šä¸æ›å—ï¼Ÿ`;
            elements.threeDoorsChoices.style.display = 'flex';
        }, 1000);
    }
    
    function resolveThreeDoors(switched) {
        const finalChoice = switched ? 
            [0, 1, 2].find(i => i !== threeDoorsState.playerChoice && i !== threeDoorsState.openedByHost) :
            threeDoorsState.playerChoice;
            
        const outcome = threeDoorsState.doors[finalChoice];
        
        document.querySelectorAll('.door').forEach((door, i) => {
            door.classList.add('opened');
            door.innerHTML = `<div class="door-content">${threeDoorsState.doors[i].text}</div>`;
        });
        document.querySelector(`.door[data-index="${finalChoice}"]`).classList.add('selected');
        
        elements.threeDoorsMessage.textContent = `ä½ çš„é¸æ“‡æ˜¯... ${outcome.text}!`;
        elements.threeDoorsChoices.style.display = 'none';
        
        logEvent(`ğŸšª å‘½é‹ä¸‰é–€çµæœï¼š${outcome.text}`);
        applyOutcome(outcome);
        
        setTimeout(() => closeModal('threeDoorsModal'), 4000);
        updateUI();
        saveState();
    }

    function generateThreeDoorsSet() {
        const prizeHours = Math.floor(Math.random() * 5) + 8; // 8-12
        const prize = { text: `-${prizeHours}å°æ™‚`, type: 'reward', value: -prizeHours * 3600, isPrize: true };
        
        const timeTrapHours = Math.floor(Math.random() * 5) + 6; // 6-10
        const timeTrap = { text: `+${timeTrapHours}å°æ™‚`, type: 'penalty', value: timeTrapHours * 3600, isPrize: false };

        const realityTraps = [
            { text: 'è¶…å¯æ€•çµ„åˆæŠ€', effect: 'super_combo'},
            { text: 'æ‰‹æ©Ÿæ’æ¯’2å°æ™‚', effect: 'add_timer', payload: 'phone_detox' },
            { text: 'æ·±å–‰åš¨å‡å±Œ10æ¬¡', effect: 'add_punishment', payload: 'dildo_punishment' },
            { text: 'ä¿„ç¾…æ–¯è½‰é«”60æ¬¡', effect: 'add_punishment', payload: 'russian_twist' },
            { text: 'ä»°è‡¥æ‘¸è…³è¸60æ¬¡', effect: 'add_punishment', payload: 'ankle_touch' },
        ];
        const chosenRealityTrap = realityTraps[Math.floor(Math.random() * realityTraps.length)];
        const realityTrap = { text: chosenRealityTrap.text, type: 'special', effect: chosenRealityTrap.effect, payload: chosenRealityTrap.payload, isPrize: false };

        return [prize, timeTrap, realityTrap];
    }
    
    function applyOutcome(outcome) {
        if (outcome.value) modifyTime(outcome.value);
        if (outcome.effect) handleSpecialOutcome(outcome.effect, outcome.payload);
    }


    // Final Unlock & Punishments
    function attemptUnlock() {
        elements.unlockBtn.disabled = true;
        logEvent('ğŸ”‘ æº–å‚™é€²è¡Œæœ€çµ‚è§£é–è³­æ³¨...');
        const isSuccess = Math.random() < 0.5;

        setTimeout(() => {
            if (isSuccess) {
                logEvent('ğŸ‰ è§£é–æˆåŠŸï¼æ­å–œä½ å®Œæˆæœ¬æ¬¡æŒ‘æˆ°ï¼');
                showFinalUnlockModal('ğŸ‰ è§£é–æˆåŠŸï¼', 'æ­å–œä½ å®Œæˆäº†é€™å€‹è‰±é‰…çš„æŒ‘æˆ°ï¼');
                gameState = {};
                localStorage.removeItem('abstinenceGameState_v6.6');
            } else {
                logEvent('âŒ è§£é–å¤±æ•—ï¼è§¸ç™¼æœ€çµ‚æ‡²ç½°...');
                applyFinalPenalty();
            }
        }, 2000);
    }
    
    function applyFinalPenalty() {
        const rand = Math.random() * 100;
        let penaltyMessage;
        if (rand < 55) { const h = (Math.floor(Math.random()*3)+1); modifyTime(h*3600); penaltyMessage = `æ™‚é–“æ‡²ç½°(å°)-å¢åŠ ${h}å°æ™‚`; }
        else if (rand < 75) { const h = (Math.floor(Math.random()*4)+3); modifyTime(h*3600); penaltyMessage = `æ™‚é–“æ‡²ç½°(ä¸­)-å¢åŠ ${h}å°æ™‚`; }
        else if (rand < 85) { const h = (Math.floor(Math.random()*7)+6); modifyTime(h*3600); penaltyMessage = `æ™‚é–“æ‡²ç½°(å¤§)-å¢åŠ ${h}å°æ™‚`; }
        else if (rand < 95) { penaltyMessage = `è²æ“é–æŒ‘æˆ°-ç”Ÿæˆ1å°æ™‚æŒ‘æˆ°`; addTimer('chastity_lock'); }
        else if (rand < 98) { penaltyMessage = `ç¾å¯¦æ‡²ç½°-ç”Ÿæˆæ¶¼å·¾èˆ‡åˆ®é¬æ³¡å„1æ¬¡`; addPunishment('towel_punishment', 1); addPunishment('foam_punishment', 1); }
        else { const t = gameState.totalChallengeTime/1000; penaltyMessage = `å²è©©ç´šæ‡²ç½°-å¢åŠ åˆå§‹ç¸½æ™‚é•·(${formatDuration(t)})`; modifyTime(t, false); }
        
        logEvent(`ğŸ’¥ æœ€çµ‚æ‡²ç½°è§¸ç™¼ï¼š${penaltyMessage}`);
        showFinalUnlockModal('âŒ è§£é–å¤±æ•—ï¼', `è§¸ç™¼æ‡²ç½°ï¼š${penaltyMessage}<br>æŒ‘æˆ°ä»åœ¨ç¹¼çºŒï¼`);
        saveState();
        startTimer();
        updateUI();
    }

    function showFinalUnlockModal(title, message) {
        document.getElementById('finalUnlockTitle').innerHTML = title;
        document.getElementById('finalUnlockMessage').innerHTML = message;
        openModal('finalUnlockModal');
    }
    
    function handleSpecialOutcome(effect, payload) {
        switch(effect) {
            case 'add_punishment':
                addPunishment(payload, 1);
                break;
            case 'add_timer':
                addTimer(payload);
                break;
            case 'reduce_timer':
                if (gameState.timers.length > 0) {
                    const timer = gameState.timers.find(t => t.type === payload) || gameState.timers[0];
                    if (timer) {
                        timer.duration -= 30 * 60 * 1000;
                        logEvent(`âœ¨ ç¥ç¦ï¼ä¸€å€‹ã€Œ${timer.name}ã€æ™‚é–“æ¸›å°‘äº†30åˆ†é˜ï¼`);
                    }
                } else { logEvent(`âœ¨ ç¥ç¦ï¼ä½†æ²’æœ‰è¨ˆæ™‚å™¨å¯ä»¥æ¸›å°‘ã€‚`); }
                break;
            case 'all_charges_plus_one':
                Object.keys(gameState.chargeTimers).forEach(key => gameState[key + 'Charges']++);
                logEvent('âš¡ æ¬Šåˆ©æ¹§ç¾ï¼æ‰€æœ‰æ©Ÿåˆ¶çš„æ¬Šåˆ©+1ï¼');
                break;
            case 'remove_timer':
                const timerIndex = gameState.timers.findIndex(t => t.type === payload);
                if (timerIndex > -1) {
                    const timerName = gameState.timers[timerIndex].name;
                    gameState.timers.splice(timerIndex, 1);
                    logEvent(`ğŸ”“ å¥‡è¹Ÿç™¼ç”Ÿï¼ä¸€å€‹ã€Œ${timerName}ã€è¢«ç§»é™¤äº†ï¼`);
                } else { logEvent('ğŸ¤· æ²’æœ‰å°æ‡‰çš„è¨ˆæ™‚å™¨å¯ä»¥ç§»é™¤ã€‚'); }
                break;
            case 'super_combo':
                logEvent('ğŸ’¥ğŸ’¥ğŸ’¥ è¶…å¯æ€•çµ„åˆæŠ€ï¼ç²å¾—è²æ“é–ã€æ¶¼å·¾ã€åˆ®é¬æ³¡æ‡²ç½°å…¨é¤ï¼');
                addTimer('chastity_lock');
                addPunishment('towel_punishment', 1);
                addPunishment('foam_punishment', 1);
                break;
            case 'copy_slot_positive':
                if (gameState.lastSlotResult && gameState.lastSlotResult.type === 'reward') {
                    logEvent(`ğŸ”„ ç…‰æˆï¼è¤‡è£½äº†ä¸Šæ¬¡çš„æ­£é¢æ‹‰éœ¸çµæœã€Œ${gameState.lastSlotResult.text}ã€ï¼`);
                    modifyTime(gameState.lastSlotResult.value);
                } else { logEvent('ğŸ¤· ç„¡æ³•è¤‡è£½ï¼Œä¸Šæ¬¡æ‹‰éœ¸ä¸æ˜¯æ­£é¢çµæœã€‚'); }
                break;
            case 'copy_slot_negative':
                 if (gameState.lastSlotResult && gameState.lastSlotResult.type === 'penalty') {
                    logEvent(`ğŸ’€ ç…‰æˆï¼è¤‡è£½äº†ä¸Šæ¬¡çš„è² é¢æ‹‰éœ¸çµæœã€Œ${gameState.lastSlotResult.text}ã€ï¼`);
                    modifyTime(gameState.lastSlotResult.value);
                } else { logEvent('ğŸ¤· ç„¡æ³•è¤‡è£½ï¼Œä¸Šæ¬¡æ‹‰éœ¸ä¸æ˜¯è² é¢çµæœã€‚'); }
                break;
            case 'å¼·åŒ–': case 'é çŸ¥': case 'å¹¸é‹': case 'å¯Œè¶³': case 'è™›å¼±': case 'å„é‹': case 'å …éŸŒ':
                 addBuff(effect, 9999, true); // One-time use buffs
                 break;
        }
        updateUI();
        saveState();
    }

    const timerTypes = {
        'chastity_lock': { name: 'è²æ“é–æŒ‘æˆ°', duration: 1 * 3600 * 1000, icon: 'ğŸ”’' },
        'phone_detox': { name: 'æ‰‹æ©Ÿæ’æ¯’', duration: 2 * 3600 * 1000, icon: 'ğŸ“µ' },
    };

    function addTimer(type) {
        if (!timerTypes[type]) return;
        const config = timerTypes[type];
        const newTimer = { id: Date.now(), type: type, name: config.name, icon: config.icon, duration: config.duration, startTime: Date.now() };
        gameState.timers.push(newTimer);
        logEvent(`${config.icon} æ–°å¢è¨ˆæ™‚å™¨ï¼šã€Œ${config.name}ã€ï¼`);
        renderAllTimers();
        saveState();
    }

    function updateAllTimers() {
         for (let i = gameState.timers.length - 1; i >= 0; i--) {
            const timer = gameState.timers[i];
            const elapsed = Date.now() - timer.startTime;
            const remaining = timer.duration - elapsed;
            const timerEl = document.getElementById(`timer-${timer.id}`);
            if (remaining <= 0) {
                logEvent(`âœ… è¨ˆæ™‚å™¨å®Œæˆï¼šã€Œ${timer.name}ã€ï¼`);
                if(timerEl) timerEl.remove();
                gameState.timers.splice(i, 1);
                saveState();
            } else if (timerEl) {
                timerEl.querySelector('.timer-time').textContent = formatDuration(remaining / 1000);
            }
        }
    }
    
    function renderAllTimers() {
        elements.timersArea.innerHTML = '';
        gameState.timers.forEach(timer => {
            const el = document.createElement('div');
            el.className = 'status-item timer-item';
            el.id = `timer-${timer.id}`;
            const remaining = timer.duration - (Date.now() - timer.startTime);
            el.innerHTML = `<span>${timer.icon} ${timer.name} (å‰©é¤˜ <span class="timer-time">${formatDuration(remaining / 1000)}</span>)</span><span>é€²è¡Œä¸­...</span>`;
            elements.timersArea.appendChild(el);
        });
    }

    const punishmentTypes = {
        'towel_punishment': { name: 'æ¶¼å·¾æ‡²ç½°', icon: 'ğŸ¥¶' },
        'foam_punishment': { name: 'åˆ®é¬æ³¡æ‡²ç½°', icon: 'â˜ï¸' },
        'dildo_punishment': { name: 'æ·±å–‰åš¨å‡å±Œ10æ¬¡', icon: 'ğŸ†' },
        'russian_twist': { name: 'ä¿„ç¾…æ–¯è½‰é«”60æ¬¡', icon: 'ğŸ’ª' },
        'ankle_touch': { name: 'ä»°è‡¥æ‘¸è…³è¸60æ¬¡', icon: 'ğŸ’ª' },
    };

    function addPunishment(type, amount) {
        if (!punishmentTypes[type]) return;
        if (!gameState.punishments[type]) {
            gameState.punishments[type] = 0;
        }
        gameState.punishments[type] += amount;
        logEvent(`${punishmentTypes[type].icon} æ–°å¢æ‡²ç½°ï¼šã€Œ${punishmentTypes[type].name}ã€ï¼`);
        renderPunishments();
        saveState();
    }
    
    function renderPunishments() {
        elements.punishmentArea.innerHTML = '';
        for (const type in gameState.punishments) {
            const count = gameState.punishments[type];
            if (count > 0) {
                const config = punishmentTypes[type];
                const el = document.createElement('div');
                el.className = 'status-item punishment-item';
                el.innerHTML = `<span>${config.icon} å¾…åŸ·è¡Œ${config.name}: ${count} æ¬¡</span><button class="btn btn-sm btn-danger">ç¢ºèªåŸ·è¡Œ</button>`;
                el.querySelector('button').addEventListener('click', () => { 
                    gameState.punishments[type]--; 
                    logEvent(`${config.icon} ä½ å®Œæˆäº†ä¸€æ¬¡${config.name}ï¼`); 
                    renderPunishments(); 
                    saveState(); 
                });
                elements.punishmentArea.appendChild(el);
            }
        }
    }

    // --- Event Listeners ---
    elements.newChallengeBtn.addEventListener('click', () => openModal('difficultyModal'));
    elements.difficultySelection.addEventListener('click', (e) => {
        if (e.target.tagName === 'BUTTON') {
            startNewChallenge(parseInt(e.target.dataset.level), parseFloat(e.target.dataset.multiplier));
        }
    });
    elements.diceBtn.addEventListener('click', rollDice);
    elements.slotBtn.addEventListener('click', pullSlotMachine);
    elements.rouletteBtn.addEventListener('click', setupRoulette);
    elements.monopolyBtn.addEventListener('click', setupMonopoly);
    elements.lottoBtn.addEventListener('click', setupLotto);
    elements.threeDoorsBtn.addEventListener('click', setupThreeDoors);
    elements.unlockBtn.addEventListener('click', attemptUnlock);
    elements.finalUnlockCloseBtn.addEventListener('click', () => {
        closeModal('finalUnlockModal');
        if (!gameState.targetTime) initializeGame();
    });
    elements.spinRouletteBtn.addEventListener('click', spinRoulette);
    document.querySelectorAll('[data-bet-type="color"]').forEach(btn => {
        btn.addEventListener('click', () => placeRouletteBet('color', btn.dataset.betValue));
    });
    elements.specificBetBtn.addEventListener('click', () => {
        const val = parseInt(document.getElementById('specificBetInput').value);
        if (!isNaN(val) && val >= 0 && val <= 11) placeRouletteBet('specific', val);
    });
    elements.monopolyRollBtn.addEventListener('click', rollMonopolyDice);
    elements.drawLottoBtn.addEventListener('click', drawLotto);
    document.getElementById('stickBtn').addEventListener('click', () => resolveThreeDoors(false));
    document.getElementById('switchBtn').addEventListener('click', () => resolveThreeDoors(true));

    // --- Initial Load ---
    window.onload = initializeGame;
    </script>
</body>
</html>
