<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>禁慾挑戰 v6.0</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #1a1a1a;
            --surface-color: #2c2c2c;
            --primary-color: #4a90e2;
            --secondary-color: #50e3c2;
            --text-color: #f0f0f0;
            --text-muted-color: #888;
            --danger-color: #e24a4a;
            --warning-color: #f5a623;
            --success-color: #7ed321;
            --gold-color: #ffd700;
            --font-family: 'Noto Sans TC', sans-serif;
        }

        @keyframes pulse-green {
            0% { text-shadow: 0 0 15px var(--secondary-color); }
            50% { text-shadow: 0 0 25px var(--secondary-color); }
            100% { text-shadow: 0 0 15px var(--secondary-color); }
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 1rem;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }

        .container {
            width: 100%;
            max-width: 850px; /* Increased width for 3 columns */
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .header {
            text-align: center;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 1rem;
        }

        .header h1 {
            margin: 0;
            font-size: 2.5rem;
            color: var(--primary-color);
            text-shadow: 0 0 10px var(--primary-color);
        }

        .timer-display {
            font-size: 4rem;
            font-weight: 700;
            text-align: center;
            color: var(--secondary-color);
            background-color: var(--surface-color);
            padding: 1rem;
            border-radius: 1rem;
            letter-spacing: 0.1em;
            animation: pulse-green 2s infinite;
        }
        
        #buff-area {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: center;
        }
        
        .buff-item {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            width: 80%;
            max-width: 500px;
            text-align: left;
        }
        .buff-item.buff { background-color: rgba(126, 211, 33, 0.2); border: 1px solid var(--success-color); }
        .buff-item.debuff { background-color: rgba(226, 74, 74, 0.15); border: 1px solid var(--danger-color); }

        .buff-header {
            font-weight: bold;
            font-size: 0.9rem;
        }
        .buff-header.buff { color: var(--success-color); }
        .buff-header.debuff { color: var(--danger-color); }

        .buff-description {
            font-size: 0.8rem;
            color: var(--text-color);
        }

        #punishmentArea, #timersArea {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .status-item {
            border-radius: 0.5rem;
            padding: 0.75rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
        }
        .status-item span { font-weight: bold; }
        
        .timer-item { background-color: rgba(245, 166, 35, 0.2); border: 1px solid var(--warning-color); }
        .timer-item span { color: var(--warning-color); }

        .punishment-item { background-color: rgba(226, 74, 74, 0.15); border: 1px solid var(--danger-color); }
        .punishment-item span { color: var(--danger-color); }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
        }
        
        .control-card {
            background-color: var(--surface-color);
            border-radius: 1rem;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem; /* Reduced gap */
            border: 1px solid transparent;
            transition: all 0.3s ease;
        }

        .control-card h3 {
            margin: 0 0 0.5rem 0;
            font-size: 1.5rem;
            color: var(--primary-color);
            text-align: center;
        }
        
        .control-card .charge-info { font-size: 0.8rem; color: var(--text-muted-color); background-color: #333; padding: 0.2rem 0.5rem; border-radius: 0.5rem; }
        .control-card .charge-cooldown { font-size: 0.8rem; color: var(--text-muted-color); margin: 0.5rem 0 0 0; }
        .control-card .description { margin: 0.5rem 0; font-size: 0.9rem; color: var(--text-muted-color); text-align: center; min-height: 2.7em; }
        .charge-count-display { font-size: 0.9rem; color: var(--secondary-color); margin-top: 0.5rem; font-weight: bold; }

        .btn { font-family: var(--font-family); padding: 0.75rem 1.5rem; font-size: 1rem; font-weight: 500; border: none; border-radius: 0.5rem; cursor: pointer; transition: all 0.3s ease; width: 100%; display: flex; justify-content: center; align-items: center; gap: 0.5rem; }
        .btn-primary { background-color: var(--primary-color); color: white; box-shadow: 0 4px 15px -5px var(--primary-color); }
        .btn-primary:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 6px 20px -5px var(--primary-color); }
        .btn-danger { background-color: var(--danger-color); color: white; }
        .btn-warning { background-color: var(--warning-color); color: white; }
        .btn:disabled { background-color: #555; color: #888; cursor: not-allowed; box-shadow: none; }
        
        .dice-area { display: flex; gap: 2rem; margin-top: 0.5rem; padding: 1rem; background-color: #1f1f1f; border-radius: 0.5rem; }
        .dice-container { display: flex; flex-direction: column; align-items: center; gap: 0.5rem; }
        .dice-label { font-size: 1rem; font-weight: 500; color: var(--text-muted-color); }
        .dice { width: 60px; height: 60px; background-color: #fff; border-radius: 10px; display: flex; justify-content: center; align-items: center; color: var(--bg-color); font-weight: bold; box-shadow: 0 2px 5px rgba(0,0,0,0.2); font-size: 3rem; }

        .slot-machine-container { width: 100%; max-width: 300px; height: 80px; background: #111; border-radius: 10px; overflow: hidden; position: relative; border: 3px solid var(--primary-color); box-shadow: inset 0 0 10px rgba(0,0,0,0.5); margin: 0.5rem 0; }
        .slot-reels { position: absolute; top: 0; left: 0; right: 0; transition: top 4s cubic-bezier(0.25, 1, 0.5, 1); }
        .slot-item { height: 80px; display: flex; justify-content: center; align-items: center; font-size: 1.5rem; font-weight: bold; }
        .slot-item.reward { color: var(--success-color); }
        .slot-item.penalty { color: var(--danger-color); }
        .slot-item.special { color: var(--secondary-color); }

        .log-section { background-color: var(--surface-color); border-radius: 1rem; padding: 1rem; }
        .log-section h3 { margin-top: 0; color: var(--primary-color); border-bottom: 1px solid var(--text-muted-color); padding-bottom: 0.5rem; }
        #eventLog { height: 250px; overflow-y: auto; padding-right: 10px; }
        #eventLog p { margin: 0.5rem 0; font-size: 0.875rem; border-bottom: 1px solid #444; padding-bottom: 0.5rem; }
        #eventLog p:last-child { border-bottom: none; }
        
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.85); display: none; justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background-color: var(--surface-color); padding: 1.5rem 2rem; border-radius: 1rem; text-align: center; width: 95%; max-width: 700px; box-shadow: 0 5px 25px rgba(0,0,0,0.5); display: flex; flex-direction: column; gap: 1.5rem; }
        
        #difficultySelection button, #rouletteBets button { margin: 0.5rem; }
        
        /* Roulette Styles */
        #rouletteWheel { position: relative; width: 300px; height: 300px; border-radius: 50%; border: 5px solid var(--gold-color); margin: 1rem auto; transition: transform 6s cubic-bezier(0.2, 0.8, 0.2, 1); }
        .roulette-slice { position: absolute; width: 100%; height: 100%; clip-path: polygon(50% 50%, 50% 0, 75% 0); /* 30 deg slice */ }
        .roulette-slice span { position: absolute; top: 10px; left: 55%; transform: translateX(-50%); font-weight: bold; font-size: 0.9rem; }
        #roulettePointer { position: absolute; top: -25px; left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 15px solid transparent; border-right: 15px solid transparent; border-top: 25px solid var(--gold-color); }

        /* Monopoly Styles */
        #monopolyBoard { display: grid; /* grid-template-columns is set by JS */ gap: 4px; background: #111; padding: 8px; border-radius: 8px; position: relative; }
        .board-cell { width: 100%; padding-top: 100%; position: relative; border-radius: 4px; font-size: 9px; font-weight: bold; color: white; line-height: 1.1; }
        .board-cell-content { position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; justify-content: center; align-items: center; padding: 2px; flex-direction: column; text-align: center;}
        .cell-start { background-color: var(--primary-color); }
        .cell-reward { background-color: var(--success-color); }
        .cell-penalty { background-color: var(--danger-color); }
        .cell-buff { background-color: #3a9a9a; }
        .cell-debuff { background-color: #8b008b; }
        .cell-special { background: linear-gradient(45deg, var(--warning-color), var(--gold-color)); }
        #playerPiece { position: absolute; width: 20px; height: 20px; background-color: var(--secondary-color); border-radius: 50%; border: 2px solid white; transition: all 0.5s ease-in-out; z-index: 5; box-shadow: 0 0 10px var(--secondary-color); }
        #monopolyInfo { display: flex; justify-content: space-around; align-items: center; gap: 1rem; }
        #monopolyEventText { flex: 1; text-align: center; font-weight: bold; }

        /* Lotto Styles */
        #lottoGrid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 0.5rem; margin: 1rem 0; }
        .lotto-number { padding: 0.8rem; border: 1px solid var(--text-muted-color); border-radius: 50%; cursor: pointer; transition: all 0.2s ease; }
        .lotto-number.selected { background-color: var(--primary-color); color: white; border-color: var(--primary-color); }

        /* Three Doors Styles */
        #threeDoorsContainer { display: flex; justify-content: space-around; gap: 1rem; margin: 1rem 0; }
        .door { width: 120px; height: 180px; border: 3px solid var(--gold-color); border-radius: 10px; background-color: #4a2c0f; cursor: pointer; transition: all 0.3s ease; display: flex; justify-content: center; align-items: center; font-size: 4rem; color: var(--gold-color); }
        .door:hover { transform: scale(1.05); }
        .door.selected { border-color: var(--secondary-color); box-shadow: 0 0 20px var(--secondary-color); }
        .door.opened { background-color: #111; cursor: default; }
        .door .door-content { font-size: 1.2rem; font-weight: bold; padding: 0.5rem; text-align: center; }
        #threeDoorsChoices { display: none; gap: 1rem; justify-content: center; }

    </style>
</head>
<body>

    <div class="container">
        <!-- Header and Timer -->
        <header class="header">
            <h1>🌟 禁慾挑戰 🌟</h1>
        </header>
        <div id="timerDisplay" class="timer-display"><span id="timerText">00:00:00</span></div>
        <div id="buff-area"></div>
        
        <!-- Punishments -->
        <div id="timersArea"></div>
        <div id="punishmentArea"></div>

        <!-- Unlock Section -->
        <div id="unlockSection" style="display: none; text-align: center;">
             <p>🎉 恭喜！計時器已歸零！🎉</p>
            <button id="unlockBtn" class="btn btn-secondary btn-lg" style="max-width: 300px; margin: auto;">🎰 進行最終的解鎖賭注</button>
        </div>

        <!-- Main Controls -->
        <div class="controls-grid">
            <div id="diceCard" class="control-card">
                <h3>🎲 雙骰對決</h3>
                <p class="charge-info">每 30 分鐘累積 1 次</p>
                <div class="dice-area">
                    <div class="dice-container"><span class="dice-label">你</span><div id="playerDice" class="dice">?</div></div>
                    <div class="dice-container"><span class="dice-label">Bot</span><div id="botDice" class="dice">?</div></div>
                </div>
                <button id="diceBtn" class="btn btn-primary">擲骰</button>
                <p class="charge-count-display">可用次數: <span id="diceCharges">0</span></p>
                <p class="charge-cooldown" id="diceCooldown">下次累積: ...</p>
            </div>
            
            <div id="slotCard" class="control-card">
                <h3>🎰 命運拉霸機</h3>
                <p class="charge-info">每 30 分鐘累積 1 次</p>
                <div class="slot-machine-container"><div id="slotReels" class="slot-reels"></div></div>
                <button id="slotBtn" class="btn btn-primary">拉霸</button>
                <p class="charge-count-display">可用次數: <span id="slotCharges">0</span></p>
                <p class="charge-cooldown" id="slotCooldown">下次累積: ...</p>
            </div>

            <div id="rouletteCard" class="control-card">
                <h3>😈 魔鬼的輪盤</h3>
                <p class="charge-info">每 3 小時累積 1 次</p>
                <p class="description">高風險、高回報的策略賭博。金色頭獎可以讓你瞬間減少24小時！</p>
                <button id="rouletteBtn" class="btn btn-primary">遊玩</button>
                <p class="charge-count-display">可用次數: <span id="rouletteCharges">0</span></p>
                <p class="charge-cooldown" id="rouletteCooldown">下次累積: ...</p>
            </div>

            <div id="monopolyCard" class="control-card">
                <h3>🗺️ 命運棋盤</h3>
                <p class="charge-info">每 1 小時累積 1 次</p>
                <p class="description">啟動連鎖煉金陣！強化你的其他操作，打出意想不到的組合技！</p>
                <button id="monopolyBtn" class="btn btn-primary">進入</button>
                <p class="charge-count-display">可用次數: <span id="monopolyCharges">0</span></p>
                <p class="charge-cooldown" id="monopolyCooldown">下次累積: ...</p>
            </div>

            <div id="lottoCard" class="control-card">
                <h3>🎟️ 即時時間彩</h3>
                <p class="charge-info">每 3 小時累積 1 次</p>
                <p class="description">花費30分鐘成本，立即對獎！對中5碼，直接減少48小時！</p>
                <button id="lottoBtn" class="btn btn-primary">遊玩</button>
                <p class="charge-count-display">可用次數: <span id="lottoCharges">0</span></p>
                <p class="charge-cooldown" id="lottoCooldown">下次累積: ...</p>
            </div>
            
            <div id="threeDoorsCard" class="control-card">
                <h3>🚪 命運三門</h3>
                <p class="charge-info">每 4 小時累積 1 次</p>
                <p class="description">經典的三選一心理博弈。門後是天堂還是地獄，換不換門由你決定！</p>
                <button id="threeDoorsBtn" class="btn btn-primary">遊玩</button>
                <p class="charge-count-display">可用次數: <span id="threeDoorsCharges">0</span></p>
                <p class="charge-cooldown" id="threeDoorsCooldown">下次累積: ...</p>
            </div>
        </div>

        <!-- Log -->
        <div class="log-section">
            <h3>📜 事件紀錄</h3>
            <div id="eventLog"></div>
        </div>

        <button id="newChallengeBtn" class="btn btn-danger">🌱 開啟新挑戰</button>
    </div>
    
    <!-- Modals -->
    <div id="difficultyModal" class="modal-overlay">
        <div class="modal-content">
            <h2>選擇挑戰難度</h2>
            <p>難度將生成一個「乘數」，影響所有與時間相關的獎懲與成本。</p>
            <div id="difficultySelection">
                <button class="btn btn-primary" data-level="1" data-multiplier="1.0">等級1 (新手 x1.0)</button>
                <button class="btn btn-primary" data-level="2" data-multiplier="1.5">等級2 (熟練 x1.5)</button>
                <button class="btn btn-primary" data-level="3" data-multiplier="2.25">等級3 (精英 x2.25)</button>
                <button class="btn btn-warning" data-level="4" data-multiplier="3.375">等級4 (專家 x3.375)</button>
                <button class="btn btn-danger" data-level="5" data-multiplier="5.0625">等級5 (傳說 x5.0625)</button>
            </div>
        </div>
    </div>
    
    <div id="finalUnlockModal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="finalUnlockTitle"></h2>
            <p id="finalUnlockMessage"></p>
            <button id="finalUnlockCloseBtn" class="btn btn-primary">我明白了</button>
        </div>
    </div>

    <div id="rouletteModal" class="modal-overlay">
        <div class="modal-content">
            <h2>😈 魔鬼的輪盤</h2>
            <div style="position: relative; width: 300px; margin: 0 auto;">
                <div id="rouletteWheel"></div>
                <div id="roulettePointer"></div>
            </div>
            <p id="rouletteResultText">下注來決定你的命運！</p>
            <div id="rouletteBets">
                <p><strong>下注會預先支付時間成本！</strong></p>
                <button class="btn btn-secondary" data-bet-type="color" data-bet-value="red">穩健下注: 紅色 (-15m)</button>
                <button class="btn btn-secondary" data-bet-type="color" data-bet-value="black">穩健下注: 黑色 (-15m)</button>
                <br>
                <input type="number" id="specificBetInput" placeholder="精準下注格號 (0-11)" min="0" max="11" style="padding: 0.5rem; border-radius: 0.5rem; border: 1px solid #888; background: #333; color: white; width: 200px; margin-right: 10px;">
                <button id="specificBetBtn" class="btn btn-warning">下注 (-30m)</button>
            </div>
            <div>
                <button id="spinRouletteBtn" class="btn btn-primary" style="margin-top: 1rem;">開始轉動！</button>
                <button class="btn" onclick="closeModal('rouletteModal')">離開</button>
            </div>
        </div>
    </div>

    <div id="monopolyModal" class="modal-overlay">
        <div class="modal-content">
            <h2>🗺️ 命運棋盤</h2>
            <div id="monopolyBoard"><div id="playerPiece"></div></div>
            <div id="monopolyInfo">
                <div id="monopolyDiceResult" class="dice">?</div>
                <button id="monopolyRollBtn" class="btn btn-primary" style="width: auto;">擲骰前進</button>
                <p id="monopolyEventText">擲骰來決定你的命運！</p>
            </div>
            <button class="btn" onclick="closeModal('monopolyModal')">離開棋盤</button>
        </div>
    </div>

    <div id="lottoModal" class="modal-overlay">
        <div class="modal-content">
            <h2>🎟️ 即時時間彩</h2>
            <p>選擇 5 個幸運數字 (1-30)。每次遊玩成本為 30 分鐘。</p>
            <div id="lottoGrid"></div>
            <p>已選號碼: <span id="lottoSelectionText"></span></p>
            <p id="lottoResultArea" style="font-weight: bold;"></p>
            <div>
                <button id="drawLottoBtn" class="btn btn-primary" disabled>立即開獎 (-30m)</button>
                <button class="btn" onclick="closeModal('lottoModal')">關閉</button>
            </div>
        </div>
    </div>

    <div id="threeDoorsModal" class="modal-overlay">
        <div class="modal-content">
            <h2>🚪 命運三門</h2>
            <p id="threeDoorsMessage">選擇一扇門，看看你的命運如何！</p>
            <div id="threeDoorsContainer">
                <div class="door" data-index="0"><span>?</span></div>
                <div class="door" data-index="1"><span>?</span></div>
                <div class="door" data-index="2"><span>?</span></div>
            </div>
            <div id="threeDoorsChoices">
                <button id="stickBtn" class="btn btn-primary">堅持選擇</button>
                <button id="switchBtn" class="btn btn-secondary">交換選擇</button>
            </div>
        </div>
    </div>

    <script>
    // --- Full v6.0 Script ---
    
    // --- DOM Elements ---
    const elements = {
        timerText: document.getElementById('timerText'),
        unlockSection: document.getElementById('unlockSection'),
        unlockBtn: document.getElementById('unlockBtn'),
        newChallengeBtn: document.getElementById('newChallengeBtn'),
        eventLog: document.getElementById('eventLog'),
        buffArea: document.getElementById('buff-area'),
        
        diceBtn: document.getElementById('diceBtn'),
        diceChargesSpan: document.getElementById('diceCharges'),
        playerDiceDiv: document.getElementById('playerDice'),
        botDiceDiv: document.getElementById('botDice'),
        diceCooldown: document.getElementById('diceCooldown'),
        
        slotBtn: document.getElementById('slotBtn'),
        slotReels: document.getElementById('slotReels'),
        slotChargesSpan: document.getElementById('slotCharges'),
        slotCooldown: document.getElementById('slotCooldown'),

        rouletteBtn: document.getElementById('rouletteBtn'),
        rouletteChargesSpan: document.getElementById('rouletteCharges'),
        rouletteModal: document.getElementById('rouletteModal'),
        rouletteWheel: document.getElementById('rouletteWheel'),
        rouletteResultText: document.getElementById('rouletteResultText'),
        spinRouletteBtn: document.getElementById('spinRouletteBtn'),
        specificBetBtn: document.getElementById('specificBetBtn'),
        rouletteCooldown: document.getElementById('rouletteCooldown'),

        monopolyBtn: document.getElementById('monopolyBtn'),
        monopolyChargesSpan: document.getElementById('monopolyCharges'),
        monopolyModal: document.getElementById('monopolyModal'),
        monopolyBoard: document.getElementById('monopolyBoard'),
        monopolyRollBtn: document.getElementById('monopolyRollBtn'),
        monopolyDiceResult: document.getElementById('monopolyDiceResult'),
        monopolyEventText: document.getElementById('monopolyEventText'),
        monopolyCooldown: document.getElementById('monopolyCooldown'),

        lottoBtn: document.getElementById('lottoBtn'),
        lottoModal: document.getElementById('lottoModal'),
        lottoGrid: document.getElementById('lottoGrid'),
        lottoSelectionText: document.getElementById('lottoSelectionText'),
        drawLottoBtn: document.getElementById('drawLottoBtn'),
        lottoResultArea: document.getElementById('lottoResultArea'),
        lottoCharges: document.getElementById('lottoCharges'),
        lottoCooldown: document.getElementById('lottoCooldown'),
        
        threeDoorsBtn: document.getElementById('threeDoorsBtn'),
        threeDoorsModal: document.getElementById('threeDoorsModal'),
        threeDoorsContainer: document.getElementById('threeDoorsContainer'),
        threeDoorsMessage: document.getElementById('threeDoorsMessage'),
        threeDoorsChoices: document.getElementById('threeDoorsChoices'),
        threeDoorsCharges: document.getElementById('threeDoorsCharges'),
        threeDoorsCooldown: document.getElementById('threeDoorsCooldown'),
        
        timersArea: document.getElementById('timersArea'),
        punishmentArea: document.getElementById('punishmentArea'),

        difficultyModal: document.getElementById('difficultyModal'),
        difficultySelection: document.getElementById('difficultySelection'),
        finalUnlockModal: document.getElementById('finalUnlockModal'),
        finalUnlockCloseBtn: document.getElementById('finalUnlockCloseBtn'),
    };

    // --- Game State ---
    let gameState = {};
    let timerInterval;
    let monopolyCellCoords = [];
    let lottoSelection = [];
    let threeDoorsState = {};

    const defaultGameState = {
        startTime: null, targetTime: null, totalChallengeTime: 0,
        difficulty: 1, difficultyMultiplier: 1.0,
        chargeTimers: { dice: 0, slot: 0, roulette: 0, monopoly: 0, lotto: 0, threeDoors: 0 },
        diceCharges: 1, slotCharges: 1, rouletteCharges: 1, monopolyCharges: 1, lottoCharges: 1, threeDoorsCharges: 1,
        timers: [], // Generic timer array for chastity, phone detox etc.
        punishments: {}, // { punishment_key: count }
        monopolyPosition: 0, monopolyBoardMap: [],
        activeBuffs: {}, // { buffId: { name, expiry, value } }
        lastSlotResult: null, // { type, value, text }
        eventLog: [],
    };

    // --- Game Data ---
    const intervals = {
        dice: 30 * 60 * 1000, 
        slot: 30 * 60 * 1000,
        roulette: 3 * 60 * 60 * 1000, 
        monopoly: 1 * 60 * 60 * 1000,
        lotto: 3 * 60 * 60 * 1000,
        threeDoors: 4 * 60 * 60 * 1000,
    };
    const diceFaces = ['⚀', '⚁', '⚂', '⚃', '⚄', '⚅'];
    const slotOutcomes = [
        { text: "-4h", type: 'reward', value: -4 * 3600 }, { text: "-2h", type: 'reward', value: -2 * 3600 },
        { text: "-1h", type: 'reward', value: -1 * 3600 }, { text: "+4h", type: 'penalty', value: 4 * 3600 },
        { text: "+2h", type: 'penalty', value: 2 * 3600 }, { text: "+1h", type: 'penalty', value: 1 * 3600 },
        { text: "貞操鎖-30m", type: 'special', effect: 'reduce_timer', payload: 'chastity_lock' },
        { text: "涼巾懲罰", type: 'special', effect: 'add_punishment', payload: 'towel_punishment' },
        { text: "刮鬍泡懲罰", type: 'special', effect: 'add_punishment', payload: 'foam_punishment' },
    ];
    const rouletteOutcomes = [
        { text: "-24h", type: 'reward', value: -24*3600, color: 'gold' }, { text: "+24h", type: 'penalty', value: 24*3600, color: 'black' },
        { text: "-3h", type: 'reward', value: -3*3600, color: 'red' }, { text: "+4h", type: 'penalty', value: 4*3600, color: 'black' },
        { text: "-1h", type: 'reward', value: -1*3600, color: 'red' }, { text: "+2h", type: 'penalty', value: 2*3600, color: 'black' },
        { text: "權利+1", type: 'special', effect: 'all_charges_plus_one', color: 'red' }, { text: "+1h", type: 'penalty', value: 1*3600, color: 'black' },
        { text: "貞操鎖", type: 'special', effect: 'add_timer', payload: 'chastity_lock' }, { text: "-1h", type: 'reward', value: -1*3600, color: 'red' },
        { text: "涼巾懲罰", type: 'special', effect: 'add_punishment', payload: 'towel_punishment' }, { text: "-3h", type: 'reward', value: -3*3600, color: 'red' },
    ];
    const buffDescriptions = {
        '強化': '下次「雙骰對決」勝利時獎勵翻倍 (一次性)。',
        '預知': '下次「命運拉霸機」的結果將被預先揭示 (一次性)。',
        '幸運': '下次「命運拉霸機」將移除所有負面結果 (一次性)。',
        '加速': '所有權利的累積速度 x2。',
        '堅韌': '所有增加的時間懲罰減少 50%。',
        '富足': '下次通過「命運棋盤」起點時獎勵翻倍 (一次性)。',
        '虛弱': '下次「雙骰對決」失敗時懲罰翻倍 (一次性)。',
        '厄運': '下次「命運拉霸機」將移除所有正面結果 (一次性)。',
        '遲緩': '所有權利的累積暫時停止。',
        '脆弱': '所有增加的時間懲罰增加 50%。',
    };

    // --- Initialization ---
    function initializeGame() {
        loadState();
        renderSlotMachine();
        buildRouletteWheel();
        buildLottoGrid();
        
        if (!gameState.targetTime) {
            timerText.textContent = "00:00:00";
            disableAllControls();
            elements.unlockSection.style.display = 'none';
            elements.newChallengeBtn.style.display = 'block';
        } else {
            startTimer();
            elements.newChallengeBtn.style.display = 'none';
            if (gameState.monopolyBoardMap.length > 0) renderMonopolyBoard();
        }
        updateUI();
    }

    // --- Core Game Loop & UI Updates ---
    function startNewChallenge(level, multiplier) {
        elements.difficultyModal.style.display = 'none';
        const initialHours = Math.random() * 12 + 12; // Random 12-24 hours
        const initialDuration = Math.floor(initialHours * 3600 * 1000 * multiplier); // Multiplied by difficulty
        const now = Date.now();
        
        gameState = JSON.parse(JSON.stringify(defaultGameState));
        gameState.difficulty = level;
        gameState.difficultyMultiplier = multiplier;
        gameState.startTime = now;
        gameState.targetTime = now + initialDuration;
        gameState.totalChallengeTime = initialDuration;
        
        // Setup initial charge timers
        gameState.chargeTimers = {
            dice: now + intervals.dice,
            slot: now + intervals.slot,
            roulette: now + intervals.roulette,
            monopoly: now + intervals.monopoly,
            lotto: now + intervals.lotto,
            threeDoors: now + intervals.threeDoors,
        };
        
        generateMonopolyBoard();
        renderMonopolyBoard();

        logEvent(`🌱 等級 ${level} (x${multiplier}) 挑戰開始！初始時長：${formatDuration(initialDuration / 1000)}。`);
        saveState();
        startTimer();
        elements.newChallengeBtn.style.display = 'none';
        elements.unlockSection.style.display = 'none';
        updateUI();
    }

    function startTimer() {
        if (timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(update, 1000);
    }

    function update() {
        if (!gameState.targetTime) {
            clearInterval(timerInterval);
            timerInterval = null;
            return;
        }

        const now = Date.now();
        let remaining = Math.round((gameState.targetTime - now) / 1000);

        if (remaining <= 0) {
            elements.timerText.textContent = "00:00:00";
            if(timerInterval) clearInterval(timerInterval);
            timerInterval = null;
            gameState.targetTime = null; 
            saveState();
            elements.unlockSection.style.display = 'block';
            elements.unlockBtn.disabled = false;
            disableAllControls();
        } else {
            updateCharges();
            updateBuffs();
            updateAllTimers();
        }
        
        updateTimerDisplay();
        updateButtonStates();
        updateCooldownDisplays();
    }
    
    function updateCharges() {
        const now = Date.now();
        const buff = getActiveBuff('遲緩');
        if (buff) {
            const timeToAdd = now - (gameState.lastChargeCalcTime || now);
            Object.keys(gameState.chargeTimers).forEach(key => {
                gameState.chargeTimers[key] += timeToAdd;
            });
            gameState.lastChargeCalcTime = now;
            return;
        }
        
        let stateChanged = false;
        const speedMultiplier = getActiveBuff('加速') ? 2 : 1;

        Object.keys(gameState.chargeTimers).forEach(key => {
            const interval = intervals[key] / speedMultiplier;
            if (now >= gameState.chargeTimers[key]) {
                const chargesToAdd = Math.floor((now - gameState.chargeTimers[key]) / interval) + 1;
                gameState[key + 'Charges'] += chargesToAdd;
                gameState.chargeTimers[key] += chargesToAdd * interval;
                stateChanged = true;
            }
        });
        
        gameState.lastChargeCalcTime = now;
        if (stateChanged) saveState();
    }
    
    function updateCooldownDisplays() {
        const now = Date.now();
        const buff = getActiveBuff('遲緩');
        
        Object.keys(elements).forEach(key => {
            if (key.endsWith('Cooldown')) {
                const feature = key.replace('Cooldown', '');
                if (gameState.chargeTimers && gameState.chargeTimers[feature] !== undefined) {
                    if (buff) {
                        elements[key].textContent = '下次累積: 暫停中';
                    } else {
                        const remaining = Math.max(0, gameState.chargeTimers[feature] - now);
                        elements[key].textContent = `下次累積: ${formatDuration(remaining / 1000)}`;
                    }
                }
            }
        });
    }

    function updateBuffs() {
        const now = Date.now();
        let changed = false;
        for (const id in gameState.activeBuffs) {
            if (now > gameState.activeBuffs[id].expiry) {
                logEvent(`✨ 效果結束：[${gameState.activeBuffs[id].name}]`);
                delete gameState.activeBuffs[id];
                changed = true;
            }
        }
        if (changed) {
            renderBuffs();
            saveState();
        }
    }

    function updateUI() {
        updateTimerDisplay();
        updateButtonStates();
        updateCooldownDisplays();
        renderLog();
        renderBuffs();
        renderAllTimers();
        renderPunishments();
    }
    
    function updateButtonStates() {
        elements.diceChargesSpan.textContent = gameState.diceCharges;
        elements.diceBtn.disabled = gameState.diceCharges <= 0;
        elements.slotChargesSpan.textContent = gameState.slotCharges;
        elements.slotBtn.disabled = gameState.slotCharges <= 0;
        elements.rouletteChargesSpan.textContent = gameState.rouletteCharges;
        elements.rouletteBtn.disabled = gameState.rouletteCharges <= 0;
        elements.monopolyChargesSpan.textContent = gameState.monopolyCharges;
        elements.monopolyBtn.disabled = gameState.monopolyCharges <= 0;
        elements.lottoCharges.textContent = gameState.lottoCharges;
        elements.lottoBtn.disabled = gameState.lottoCharges <= 0;
        elements.threeDoorsCharges.textContent = gameState.threeDoorsCharges;
        elements.threeDoorsBtn.disabled = gameState.threeDoorsCharges <= 0;
    }

    function disableAllControls() {
        elements.diceBtn.disabled = true;
        elements.slotBtn.disabled = true;
        elements.rouletteBtn.disabled = true;
        elements.monopolyBtn.disabled = true;
        elements.lottoBtn.disabled = true;
        elements.threeDoorsBtn.disabled = true;
    }

    // --- Utility Functions ---
    function formatDuration(totalSeconds) {
        if (totalSeconds < 0) totalSeconds = 0;
        const h = String(Math.floor(totalSeconds / 3600)).padStart(2, '0');
        const m = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2, '0');
        const s = String(Math.floor(totalSeconds % 60)).padStart(2, '0');
        return `${h}:${m}:${s}`;
    }

    function logEvent(message) {
        const timestamp = new Date().toLocaleString('zh-TW', { hour12: false });
        const fullMessage = `[${timestamp}] ${message}`;
        gameState.eventLog.unshift(fullMessage);
        if (gameState.eventLog.length > 100) gameState.eventLog.pop();
        renderLog();
    }
    
    function saveState() {
        localStorage.setItem('abstinenceGameState_v6.6', JSON.stringify(gameState));
    }

    function loadState() {
        const savedState = localStorage.getItem('abstinenceGameState_v6.6');
        if (savedState) {
            const parsedState = JSON.parse(savedState);
            gameState = { ...defaultGameState, ...parsedState };
            gameState.activeBuffs = parsedState.activeBuffs || {};
            gameState.chargeTimers = parsedState.chargeTimers || { dice: 0, slot: 0, roulette: 0, monopoly: 0, lotto: 0, threeDoors: 0 };
            gameState.timers = parsedState.timers || [];
            gameState.punishments = parsedState.punishments || {};
        } else {
            gameState = JSON.parse(JSON.stringify(defaultGameState));
        }
    }

    function modifyTime(seconds, useMultiplier = true) {
        let multiplier = useMultiplier ? gameState.difficultyMultiplier : 1;
        
        const toughBuff = getActiveBuff('堅韌');
        const fragileBuff = getActiveBuff('脆弱');
        if (seconds > 0 && toughBuff) multiplier *= 0.5;
        if (seconds > 0 && fragileBuff) multiplier *= 1.5;

        const finalSeconds = Math.round(seconds * multiplier);
        if (!gameState.targetTime) gameState.targetTime = Date.now();
        gameState.targetTime += finalSeconds * 1000;

        const msg = finalSeconds > 0 ? `增加 ${formatDuration(Math.abs(finalSeconds))}` : `減少 ${formatDuration(Math.abs(finalSeconds))}`;
        logEvent(`⏱️ 時間變動：${msg}。`);
        updateTimerDisplay();
        saveState();
    }
    
    function getActiveBuff(name) {
        for (const id in gameState.activeBuffs) {
            if (gameState.activeBuffs[id].name === name) return gameState.activeBuffs[id];
        }
        return null;
    }

    function addBuff(name, durationMinutes, value = null) {
        const id = Date.now();
        const expiry = id + durationMinutes * 60 * 1000;
        gameState.activeBuffs[id] = { name, expiry, value };
        logEvent(`🟩 新增效果：[${name}]，持續 ${durationMinutes} 分鐘！`);
        renderBuffs();
    }
    
    function renderBuffs() {
        elements.buffArea.innerHTML = '';
        for (const id in gameState.activeBuffs) {
            const buff = gameState.activeBuffs[id];
            const isDebuff = ['虛弱', '厄運', '遲緩', '脆弱'].includes(buff.name);
            const remaining = Math.ceil((buff.expiry - Date.now()) / 60000);
            
            const el = document.createElement('div');
            el.className = `buff-item ${isDebuff ? 'debuff' : 'buff'}`;
            
            const header = document.createElement('div');
            header.className = `buff-header ${isDebuff ? 'debuff' : 'buff'}`;
            const durationText = buff.value === true ? '(一次性)' : `(剩餘 ${remaining}m)`;
            header.textContent = `[${buff.name}] ${durationText}`;
            
            const description = document.createElement('div');
            description.className = 'buff-description';
            description.textContent = buffDescriptions[buff.name] || '未知效果';
            
            el.appendChild(header);
            el.appendChild(description);
            
            elements.buffArea.appendChild(el);
        }
    }

    function openModal(modalId) { document.getElementById(modalId).style.display = 'flex'; }
    function closeModal(modalId) { document.getElementById(modalId).style.display = 'none'; }
    
    // --- Render Functions ---
    function renderLog() { elements.eventLog.innerHTML = gameState.eventLog.map(msg => `<p>${msg}</p>`).join(''); }
    function updateTimerDisplay() {
        const remaining = gameState.targetTime ? Math.round((gameState.targetTime - Date.now()) / 1000) : 0;
        elements.timerText.textContent = formatDuration(Math.max(0, remaining));
    }
    function renderSlotMachine() {
        elements.slotReels.innerHTML = '';
        const reelItems = [...slotOutcomes, ...slotOutcomes, ...slotOutcomes];
        reelItems.forEach(item => {
            const itemEl = document.createElement('div');
            itemEl.className = `slot-item ${item.type}`;
            itemEl.textContent = item.text;
            elements.slotReels.appendChild(itemEl);
        });
    }

    // --- Feature Implementations ---

    // 1. Dice Duel
    function rollDice() {
        if (gameState.diceCharges <= 0) return;
        gameState.diceCharges--;

        const playerRoll1 = Math.floor(Math.random() * 6) + 1;
        const playerRoll2 = Math.floor(Math.random() * 6) + 1;
        const botRoll1 = Math.floor(Math.random() * 6) + 1;
        const botRoll2 = Math.floor(Math.random() * 6) + 1;
        let playerSum = playerRoll1 + playerRoll2;
        let botSum = botRoll1 + botRoll2;

        elements.playerDiceDiv.textContent = playerSum;
        elements.botDiceDiv.textContent = botSum;
        
        let difference = playerSum - botSum;
        let timeChangeSeconds = difference * -30 * 60;
        
        const strengthenBuff = getActiveBuff('強化');
        const weakenBuff = getActiveBuff('虛弱');
        
        logEvent(`🎲 雙骰對決：你擲出 ${playerSum} 點，Bot擲出 ${botSum} 點。`);
        
        if (timeChangeSeconds < 0 && strengthenBuff) {
            timeChangeSeconds *= 2;
            logEvent(`💪[強化]效果觸發，獎勵翻倍！`);
            delete gameState.activeBuffs[Object.keys(strengthenBuff)[0]]; // Consume buff
        }
        if (timeChangeSeconds > 0 && weakenBuff) {
            timeChangeSeconds *= 2;
            logEvent(`💀[虛弱]效果觸發，懲罰翻倍！`);
            delete gameState.activeBuffs[Object.keys(weakenBuff)[0]]; // Consume buff
        }

        if (timeChangeSeconds !== 0) {
             modifyTime(timeChangeSeconds);
        } else {
            logEvent(`🎲 平手！`);
        }
        
        updateUI();
        saveState();
    }

    // 2. Slot Machine
    function pullSlotMachine() {
        if (gameState.slotCharges <= 0) return;
        gameState.slotCharges--;
        elements.slotBtn.disabled = true;

        let currentPool = [...slotOutcomes];
        const luckyBuff = getActiveBuff('幸運');
        const unluckyBuff = getActiveBuff('厄運');
        const foresightBuff = getActiveBuff('預知');
        
        if (luckyBuff) {
            currentPool = currentPool.filter(o => o.type !== 'penalty');
            logEvent('🍀[幸運]效果觸發，移除了所有負面事件！');
            delete gameState.activeBuffs[Object.keys(luckyBuff)[0]];
        }
        if (unluckyBuff) {
            currentPool = currentPool.filter(o => o.type !== 'reward');
            logEvent('😈[厄運]效果觸發，移除了所有正面事件！');
            delete gameState.activeBuffs[Object.keys(unluckyBuff)[0]];
        }

        const outcome = currentPool[Math.floor(Math.random() * currentPool.length)];
        
        if (foresightBuff) {
            logEvent(`👁️[預知]效果觸發，你知道了結果是「${outcome.text}」！`);
            delete gameState.activeBuffs[Object.keys(foresightBuff)[0]];
        }
        
        const visualIndex = slotOutcomes.indexOf(outcome);
        const basePosition = slotOutcomes.length * 80;
        const targetPosition = basePosition + (visualIndex * 80);
        
        elements.slotReels.style.transition = 'none';
        elements.slotReels.style.top = '0px';

        setTimeout(() => {
            elements.slotReels.style.transition = 'top 4s cubic-bezier(0.25, 1, 0.5, 1)';
            elements.slotReels.style.top = `-${targetPosition}px`;
        }, 50);

        setTimeout(() => {
            logEvent(`🎰 命運拉霸機：轉到「${outcome.text}」。`);
            gameState.lastSlotResult = outcome;
            if (outcome.value) {
                modifyTime(outcome.value);
            } else if (outcome.effect) {
                handleSpecialOutcome(outcome.effect, outcome.payload);
            }
            updateUI();
            saveState();
        }, 4100);
    }

    // 3. Roulette
    function buildRouletteWheel() {
        elements.rouletteWheel.innerHTML = '';
        rouletteOutcomes.forEach((slice, i) => {
            const sliceEl = document.createElement('div');
            sliceEl.className = 'roulette-slice';
            const rotation = i * 30; // 360 / 12 slices
            let bgColor = slice.color === 'red' ? '#B22222' : '#1C1C1C';
            if (slice.color === 'gold') bgColor = 'gold';
            sliceEl.style.transform = `rotate(${rotation}deg)`;
            sliceEl.style.backgroundColor = bgColor;
            sliceEl.innerHTML = `<span style="color: ${slice.color === 'black' ? 'white' : 'black'}; transform: rotate(-${rotation+15}deg);">${slice.text}</span>`;
            elements.rouletteWheel.appendChild(sliceEl);
        });
    }

    let currentBet = null;
    function setupRoulette() {
        if (gameState.rouletteCharges <= 0) return;
        currentBet = null;
        elements.rouletteResultText.textContent = '下注來決定你的命運！';
        elements.spinRouletteBtn.disabled = false;
        elements.rouletteWheel.style.transition = 'none';
        elements.rouletteWheel.style.transform = 'rotate(0deg)';
        openModal('rouletteModal');
    }

    function placeRouletteBet(type, value) {
        const cost = type === 'color' ? 15*60 : 30*60;
        modifyTime(cost);
        currentBet = { type, value };
        logEvent(`🎲 輪盤下注：${type === 'color' ? '顏色' : '號碼'} ${value}，花費 ${cost/60} 分鐘。`);
    }

    function spinRoulette() {
        if (gameState.rouletteCharges <= 0) return;
        gameState.rouletteCharges--;
        elements.spinRouletteBtn.disabled = true;

        const randomIndex = Math.floor(Math.random() * rouletteOutcomes.length);
        const outcome = rouletteOutcomes[randomIndex];
        
        const degrees = 360 * 5 + (360 - randomIndex * 30) - 15; // Spin 5 times + land on slice
        elements.rouletteWheel.style.transition = 'transform 6s cubic-bezier(0.2, 0.8, 0.2, 1)';
        elements.rouletteWheel.style.transform = `rotate(${degrees}deg)`;
        
        setTimeout(() => {
            elements.rouletteResultText.textContent = `結果是：${outcome.text}!`;
            logEvent(`😈 魔鬼的輪盤結果：${outcome.text}！`);
            let finalValue = outcome.value || 0;

            // Check bet
            if (currentBet) {
                let win = false;
                if (currentBet.type === 'color' && currentBet.value === outcome.color) win = true;
                if (currentBet.type === 'specific' && currentBet.value == randomIndex) win = true; // Use == for type coercion

                if (win && finalValue < 0) {
                    const multiplier = currentBet.type === 'color' ? 2 : 3;
                    finalValue *= multiplier;
                    logEvent(`💰 下注成功！獎勵變為 ${multiplier} 倍！`);
                } else if (win) {
                    logEvent(`💰 下注成功！但結果不是時間獎勵。`);
                } else {
                    logEvent(`💸 下注失敗。`);
                }
            }

            if (finalValue !== 0) modifyTime(finalValue);
            if (outcome.effect) handleSpecialOutcome(outcome.effect, outcome.payload);
            
            updateUI();
            saveState();
        }, 6100);
    }
    
    // 4. Monopoly
    function generateMonopolyBoard() {
        // Fixed board layout based on the user-provided image
        const boardLayout = [
            { type: 'start', text: '起點 (-3h)', value: -3 * 3600 }, // 0
            { type: 'penalty', text: '+2h', value: 2 * 3600 }, // 1
            { type: 'reward', text: '-1h', value: -1 * 3600 }, // 2
            { type: 'buff', text: '幸運', effect: '幸運', duration: 0 }, // 3
            { type: 'debuff', text: '厄運', effect: '厄運', duration: 0 }, // 4
            { type: 'special', text: '移除貞操鎖', effect: 'remove_timer', payload: 'chastity_lock' }, // 5
            { type: 'penalty', text: '+3h', value: 3 * 3600 }, // 6
            { type: 'buff', text: '強化', effect: '強化', duration: 0 }, // 7
            { type: 'debuff', text: '虛弱', effect: '虛弱', duration: 0 }, // 8
            { type: 'special', text: '涼巾懲罰', effect: 'add_punishment', payload: 'towel_punishment' }, // 9
            { type: 'penalty', text: '+3h', value: 3 * 3600 }, // 10
            { type: 'buff', text: '堅韌', effect: '堅韌', duration: 30 }, // 11 ("堅定" in image)
            { type: 'debuff', text: '脆弱', effect: '脆弱', duration: 30 }, // 12
            { type: 'penalty', text: '+2h', value: 2 * 3600 }, // 13
            { type: 'reward', text: '-2h', value: -2 * 3600 }, // 14
            { type: 'buff', text: '富足', effect: '富足', duration: 0 }, // 15
            { type: 'special', text: '貞操鎖', effect: 'add_timer', payload: 'chastity_lock' }, // 16
            { type: 'reward', text: '-4h', value: -4 * 3600 }, // 17
            { type: 'special', text: '複製拉霸(負)', effect: 'copy_slot_negative' }, // 18
            { type: 'reward', text: '-1h', value: -1 * 3600 }, // 19
            { type: 'reward', text: '-3h', value: -3 * 3600 }, // 20
            { type: 'special', text: '刮鬍泡懲罰', effect: 'add_punishment', payload: 'foam_punishment' }, // 21
            { type: 'penalty', text: '+4h', value: 4 * 3600 }, // 22
            { type: 'special', text: '貞操鎖', effect: 'add_timer', payload: 'chastity_lock' }, // 23
            { type: 'reward', text: '-1h', value: -1 * 3600 }, // 24
            { type: 'special', text: '權利+1', effect: 'all_charges_plus_one' }, // 25
            { type: 'reward', text: '-2h', value: -2 * 3600 }, // 26
            { type: 'reward', text: '-3h', value: -3 * 3600 }, // 27
            { type: 'buff', text: '加速', effect: '加速', duration: 60 }, // 28
            { type: 'special', text: '權利+1', effect: 'all_charges_plus_one' }, // 29
            { type: 'reward', text: '-1h', value: -1 * 3600 }, // 30
            { type: 'buff', text: '預知', effect: '預知', duration: 0 }, // 31
            { type: 'reward', text: '-2h', value: -2 * 3600 }, // 32
            { type: 'buff', text: '堅韌', effect: '堅韌', duration: 30 }, // 33
            { type: 'penalty', text: '+2h', value: 2 * 3600 }, // 34
            { type: 'penalty', text: '+2h', value: 2 * 3600 }, // 35
        ];
        gameState.monopolyBoardMap = boardLayout;
    }
    
    function renderMonopolyBoard() {
        const board = elements.monopolyBoard;
        board.innerHTML = '';
        monopolyCellCoords = [];
        const size = 10; // 10x10 grid for this layout
        
        // Hardcode the path based on the image
        // Top row (0-9)
        for (let i = 0; i < 10; i++) monopolyCellCoords.push({ y: 0, x: i });
        // Right col (10-18)
        for (let i = 1; i < 10; i++) monopolyCellCoords.push({ y: i, x: 9 });
        // Bottom row (19-27)
        for (let i = 8; i >= 0; i--) monopolyCellCoords.push({ y: 9, x: i });
        // Left col (28-35)
        for (let i = 8; i >= 1; i--) monopolyCellCoords.push({ y: i, x: 0 });

        // Change grid layout to 10x10
        board.style.gridTemplateColumns = `repeat(${size}, 1fr)`;

        let grid = Array(size).fill(null).map(() => Array(size).fill(null));
        monopolyCellCoords.forEach((coord, index) => {
            if (grid[coord.y] && grid[coord.y][coord.x] === null) {
                grid[coord.y][coord.x] = { ...gameState.monopolyBoardMap[index], index };
            }
        });

        for (let r = 0; r < size; r++) {
            for (let c = 0; c < size; c++) {
                const cellEl = document.createElement('div');
                if (grid[r][c]) {
                    const cellData = grid[r][c];
                    cellEl.className = `board-cell cell-${cellData.type}`;
                    cellEl.innerHTML = `<div class="board-cell-content"><span>${cellData.index}</span><span>${cellData.text}</span></div>`;
                }
                board.appendChild(cellEl);
            }
        }
        board.innerHTML += '<div id="playerPiece"></div>';
        updatePlayerPiecePosition();
    }


    function updatePlayerPiecePosition() {
        const playerPieceEl = document.getElementById('playerPiece');
        if (!playerPieceEl || monopolyCellCoords.length === 0) return;
        const {x, y} = monopolyCellCoords[gameState.monopolyPosition];
        const cellWidth = elements.monopolyBoard.firstChild.offsetWidth;
        playerPieceEl.style.top = `${y * (cellWidth + 4) + cellWidth/2 - playerPieceEl.offsetHeight/2}px`;
        playerPieceEl.style.left = `${x * (cellWidth + 4) + cellWidth/2 - playerPieceEl.offsetWidth/2}px`;
    }

    function setupMonopoly() {
        if (gameState.monopolyCharges <= 0) return;
        elements.monopolyEventText.textContent = "擲骰來決定你的命運！";
        elements.monopolyDiceResult.textContent = "?";
        openModal('monopolyModal');
        updatePlayerPiecePosition();
    }

    function rollMonopolyDice() {
        if (gameState.monopolyCharges <= 0) return;
        gameState.monopolyCharges--;
        elements.monopolyRollBtn.disabled = true;

        const roll = Math.floor(Math.random() * 6) + 1;
        elements.monopolyDiceResult.textContent = diceFaces[roll - 1];
        
        const oldPosition = gameState.monopolyPosition;
        const newPosition = (oldPosition + roll) % gameState.monopolyBoardMap.length;
        
        // Animate movement
        let currentDisplayPos = oldPosition;
        const moveInterval = setInterval(() => {
            currentDisplayPos = (currentDisplayPos + 1) % gameState.monopolyBoardMap.length;
            gameState.monopolyPosition = currentDisplayPos;
            updatePlayerPiecePosition();
            if (currentDisplayPos === newPosition) {
                clearInterval(moveInterval);
                // Landed, now trigger events
                gameState.monopolyPosition = newPosition;
                if (newPosition < oldPosition) {
                    let reward = -3 * 3600;
                    if (getActiveBuff('富足')) {
                        reward *= 2;
                        logEvent('💰[富足]效果觸發，通過起點獎勵翻倍！');
                        delete gameState.activeBuffs[Object.keys(getActiveBuff('富足'))[0]];
                    }
                    logEvent('🎉 恭喜！你完成了命運棋盤一圈！');
                    modifyTime(reward);
                }
                handleMonopolyLand();
                elements.monopolyRollBtn.disabled = false;
            }
        }, 200);
    }
    
    function handleMonopolyLand() {
        const landedCell = gameState.monopolyBoardMap[gameState.monopolyPosition];
        elements.monopolyEventText.textContent = `第${gameState.monopolyPosition}格: ${landedCell.text}`;
        logEvent(`🗺️ 命運棋盤：來到第 ${gameState.monopolyPosition} 格，觸發「${landedCell.text}」！`);

        if (landedCell.value) modifyTime(landedCell.value);
        if (landedCell.effect) {
            if (landedCell.duration > 0) {
                addBuff(landedCell.effect, landedCell.duration);
            } else {
                handleSpecialOutcome(landedCell.effect, landedCell.payload);
            }
        }
        if (landedCell.type === 'start') modifyTime(-3*3600);
        
        updateUI();
        saveState();
    }

    // 5. Instant Lotto
    function buildLottoGrid() {
        elements.lottoGrid.innerHTML = '';
        for (let i = 1; i <= 30; i++) {
            const numEl = document.createElement('div');
            numEl.className = 'lotto-number';
            numEl.textContent = i;
            numEl.dataset.number = i;
            numEl.addEventListener('click', () => toggleLottoNumber(i, numEl));
            elements.lottoGrid.appendChild(numEl);
        }
    }
    
    function setupLotto() {
        if (gameState.lottoCharges <= 0) return;
        lottoSelection = [];
        updateLottoSelectionUI();
        elements.lottoResultArea.textContent = '';
        openModal('lottoModal');
    }
    
    function toggleLottoNumber(num, el) {
        const index = lottoSelection.indexOf(num);
        if (index > -1) {
            lottoSelection.splice(index, 1);
        } else if (lottoSelection.length < 5) {
            lottoSelection.push(num);
        }
        updateLottoSelectionUI();
    }
    
    function updateLottoSelectionUI() {
        lottoSelection.sort((a, b) => a - b);
        elements.lottoSelectionText.textContent = lottoSelection.join(', ') || '尚未選擇';
        document.querySelectorAll('.lotto-number').forEach(el => {
            el.classList.toggle('selected', lottoSelection.includes(parseInt(el.dataset.number)));
        });
        elements.drawLottoBtn.disabled = lottoSelection.length !== 5;
    }

    function drawLotto() {
        if (lottoSelection.length !== 5 || gameState.lottoCharges <= 0) return;
        
        gameState.lottoCharges--;
        modifyTime(30 * 60); // Cost
        logEvent(`🎟️ 購買了一張即時彩券，號碼為：${lottoSelection.join(', ')}`);
        
        const winningNumbers = new Set();
        while (winningNumbers.size < 5) {
            winningNumbers.add(Math.floor(Math.random() * 30) + 1);
        }
        const winningArray = [...winningNumbers].sort((a,b) => a-b);
        
        const matches = lottoSelection.filter(num => winningNumbers.has(num)).length;
        let reward = 0;
        let rewardText = `開獎號碼: ${winningArray.join(', ')}. 你的號碼: ${lottoSelection.join(', ')}. 對中 ${matches} 碼`;

        if (matches === 5) { reward = -48 * 3600; rewardText += '，中了頭獎！'; }
        else if (matches === 4) { reward = -12 * 3600; rewardText += '，中了二獎！'; }
        else if (matches === 3) { reward = -4 * 3600; rewardText += '，中了三獎！'; }
        else if (matches === 2) { reward = -30 * 60; rewardText += '，中了普獎，返還成本。'; }
        else { rewardText += '，未中獎。'; }
        
        elements.lottoResultArea.textContent = rewardText;
        logEvent(`🎟️ 即時開獎結果：${rewardText}`);

        if (reward !== 0) modifyTime(reward);
        
        lottoSelection = [];
        updateLottoSelectionUI();
        updateUI();
        saveState();
    }

    // 6. Three Doors of Fate
    function setupThreeDoors() {
        if (gameState.threeDoorsCharges <= 0) return;
        gameState.threeDoorsCharges--;
        
        const [prize, trap1, trap2] = generateThreeDoorsSet();
        let doors = [prize, trap1, trap2];
        for (let i = doors.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [doors[i], doors[j]] = [doors[j], doors[i]];
        }

        threeDoorsState = {
            doors: doors,
            playerChoice: null,
            openedByHost: null,
            step: 1, // 1 for initial choice, 2 for switch/stick decision
        };

        elements.threeDoorsMessage.innerHTML = `本回合獎勵：<strong style="color: var(--success-color);">${prize.text}</strong><br>陷阱：<strong style="color: var(--danger-color);">${trap1.text}</strong>、<strong style="color: var(--danger-color);">${trap2.text}</strong><br>請選擇一扇門！`;
        elements.threeDoorsChoices.style.display = 'none';
        document.querySelectorAll('.door').forEach((door, i) => {
            door.classList.remove('selected', 'opened');
            door.innerHTML = '<span>?</span>';
            door.onclick = () => chooseDoor(i);
        });

        openModal('threeDoorsModal');
    }

    function chooseDoor(index) {
        if (threeDoorsState.step !== 1) return;
        threeDoorsState.playerChoice = index;
        threeDoorsState.step = 2;

        document.querySelectorAll('.door').forEach((door, i) => {
            door.classList.toggle('selected', i === index);
            door.onclick = null; // Disable further clicks
        });

        let doorToOpen;
        for (let i = 0; i < 3; i++) {
            if (i !== threeDoorsState.playerChoice && !threeDoorsState.doors[i].isPrize) {
                doorToOpen = i;
                break;
            }
        }
        
        threeDoorsState.openedByHost = doorToOpen;

        setTimeout(() => {
            const openedDoorEl = document.querySelector(`.door[data-index="${doorToOpen}"]`);
            openedDoorEl.classList.add('opened');
            openedDoorEl.innerHTML = `<div class="door-content">${threeDoorsState.doors[doorToOpen].text}</div>`;
            
            elements.threeDoorsMessage.textContent = `主持人打開了一扇懲罰門... 你確定不換嗎？`;
            elements.threeDoorsChoices.style.display = 'flex';
        }, 1000);
    }
    
    function resolveThreeDoors(switched) {
        const finalChoice = switched ? 
            [0, 1, 2].find(i => i !== threeDoorsState.playerChoice && i !== threeDoorsState.openedByHost) :
            threeDoorsState.playerChoice;
            
        const outcome = threeDoorsState.doors[finalChoice];
        
        document.querySelectorAll('.door').forEach((door, i) => {
            door.classList.add('opened');
            door.innerHTML = `<div class="door-content">${threeDoorsState.doors[i].text}</div>`;
        });
        document.querySelector(`.door[data-index="${finalChoice}"]`).classList.add('selected');
        
        elements.threeDoorsMessage.textContent = `你的選擇是... ${outcome.text}!`;
        elements.threeDoorsChoices.style.display = 'none';
        
        logEvent(`🚪 命運三門結果：${outcome.text}`);
        applyOutcome(outcome);
        
        setTimeout(() => closeModal('threeDoorsModal'), 4000);
        updateUI();
        saveState();
    }

    function generateThreeDoorsSet() {
        const prizeHours = Math.floor(Math.random() * 5) + 8; // 8-12
        const prize = { text: `-${prizeHours}小時`, type: 'reward', value: -prizeHours * 3600, isPrize: true };
        
        const timeTrapHours = Math.floor(Math.random() * 5) + 6; // 6-10
        const timeTrap = { text: `+${timeTrapHours}小時`, type: 'penalty', value: timeTrapHours * 3600, isPrize: false };

        const realityTraps = [
            { text: '超可怕組合技', effect: 'super_combo'},
            { text: '手機排毒2小時', effect: 'add_timer', payload: 'phone_detox' },
            { text: '深喉嚨假屌10次', effect: 'add_punishment', payload: 'dildo_punishment' },
            { text: '俄羅斯轉體60次', effect: 'add_punishment', payload: 'russian_twist' },
            { text: '仰臥摸腳踝60次', effect: 'add_punishment', payload: 'ankle_touch' },
        ];
        const chosenRealityTrap = realityTraps[Math.floor(Math.random() * realityTraps.length)];
        const realityTrap = { text: chosenRealityTrap.text, type: 'special', effect: chosenRealityTrap.effect, payload: chosenRealityTrap.payload, isPrize: false };

        return [prize, timeTrap, realityTrap];
    }
    
    function applyOutcome(outcome) {
        if (outcome.value) modifyTime(outcome.value);
        if (outcome.effect) handleSpecialOutcome(outcome.effect, outcome.payload);
    }


    // Final Unlock & Punishments
    function attemptUnlock() {
        elements.unlockBtn.disabled = true;
        logEvent('🔑 準備進行最終解鎖賭注...');
        const isSuccess = Math.random() < 0.5;

        setTimeout(() => {
            if (isSuccess) {
                logEvent('🎉 解鎖成功！恭喜你完成本次挑戰！');
                showFinalUnlockModal('🎉 解鎖成功！', '恭喜你完成了這個艱鉅的挑戰！');
                gameState = {};
                localStorage.removeItem('abstinenceGameState_v6.6');
            } else {
                logEvent('❌ 解鎖失敗！觸發最終懲罰...');
                applyFinalPenalty();
            }
        }, 2000);
    }
    
    function applyFinalPenalty() {
        const rand = Math.random() * 100;
        let penaltyMessage;
        if (rand < 55) { const h = (Math.floor(Math.random()*3)+1); modifyTime(h*3600); penaltyMessage = `時間懲罰(小)-增加${h}小時`; }
        else if (rand < 75) { const h = (Math.floor(Math.random()*4)+3); modifyTime(h*3600); penaltyMessage = `時間懲罰(中)-增加${h}小時`; }
        else if (rand < 85) { const h = (Math.floor(Math.random()*7)+6); modifyTime(h*3600); penaltyMessage = `時間懲罰(大)-增加${h}小時`; }
        else if (rand < 95) { penaltyMessage = `貞操鎖挑戰-生成1小時挑戰`; addTimer('chastity_lock'); }
        else if (rand < 98) { penaltyMessage = `現實懲罰-生成涼巾與刮鬍泡各1次`; addPunishment('towel_punishment', 1); addPunishment('foam_punishment', 1); }
        else { const t = gameState.totalChallengeTime/1000; penaltyMessage = `史詩級懲罰-增加初始總時長(${formatDuration(t)})`; modifyTime(t, false); }
        
        logEvent(`💥 最終懲罰觸發：${penaltyMessage}`);
        showFinalUnlockModal('❌ 解鎖失敗！', `觸發懲罰：${penaltyMessage}<br>挑戰仍在繼續！`);
        saveState();
        startTimer();
        updateUI();
    }

    function showFinalUnlockModal(title, message) {
        document.getElementById('finalUnlockTitle').innerHTML = title;
        document.getElementById('finalUnlockMessage').innerHTML = message;
        openModal('finalUnlockModal');
    }
    
    function handleSpecialOutcome(effect, payload) {
        switch(effect) {
            case 'add_punishment':
                addPunishment(payload, 1);
                break;
            case 'add_timer':
                addTimer(payload);
                break;
            case 'reduce_timer':
                if (gameState.timers.length > 0) {
                    const timer = gameState.timers.find(t => t.type === payload) || gameState.timers[0];
                    if (timer) {
                        timer.duration -= 30 * 60 * 1000;
                        logEvent(`✨ 祝福！一個「${timer.name}」時間減少了30分鐘！`);
                    }
                } else { logEvent(`✨ 祝福！但沒有計時器可以減少。`); }
                break;
            case 'all_charges_plus_one':
                Object.keys(gameState.chargeTimers).forEach(key => gameState[key + 'Charges']++);
                logEvent('⚡ 權利湧現！所有機制的權利+1！');
                break;
            case 'remove_timer':
                const timerIndex = gameState.timers.findIndex(t => t.type === payload);
                if (timerIndex > -1) {
                    const timerName = gameState.timers[timerIndex].name;
                    gameState.timers.splice(timerIndex, 1);
                    logEvent(`🔓 奇蹟發生！一個「${timerName}」被移除了！`);
                } else { logEvent('🤷 沒有對應的計時器可以移除。'); }
                break;
            case 'super_combo':
                logEvent('💥💥💥 超可怕組合技！獲得貞操鎖、涼巾、刮鬍泡懲罰全餐！');
                addTimer('chastity_lock');
                addPunishment('towel_punishment', 1);
                addPunishment('foam_punishment', 1);
                break;
            case 'copy_slot_positive':
                if (gameState.lastSlotResult && gameState.lastSlotResult.type === 'reward') {
                    logEvent(`🔄 煉成！複製了上次的正面拉霸結果「${gameState.lastSlotResult.text}」！`);
                    modifyTime(gameState.lastSlotResult.value);
                } else { logEvent('🤷 無法複製，上次拉霸不是正面結果。'); }
                break;
            case 'copy_slot_negative':
                 if (gameState.lastSlotResult && gameState.lastSlotResult.type === 'penalty') {
                    logEvent(`💀 煉成！複製了上次的負面拉霸結果「${gameState.lastSlotResult.text}」！`);
                    modifyTime(gameState.lastSlotResult.value);
                } else { logEvent('🤷 無法複製，上次拉霸不是負面結果。'); }
                break;
            case '強化': case '預知': case '幸運': case '富足': case '虛弱': case '厄運': case '堅韌':
                 addBuff(effect, 9999, true); // One-time use buffs
                 break;
        }
        updateUI();
        saveState();
    }

    const timerTypes = {
        'chastity_lock': { name: '貞操鎖挑戰', duration: 1 * 3600 * 1000, icon: '🔒' },
        'phone_detox': { name: '手機排毒', duration: 2 * 3600 * 1000, icon: '📵' },
    };

    function addTimer(type) {
        if (!timerTypes[type]) return;
        const config = timerTypes[type];
        const newTimer = { id: Date.now(), type: type, name: config.name, icon: config.icon, duration: config.duration, startTime: Date.now() };
        gameState.timers.push(newTimer);
        logEvent(`${config.icon} 新增計時器：「${config.name}」！`);
        renderAllTimers();
        saveState();
    }

    function updateAllTimers() {
         for (let i = gameState.timers.length - 1; i >= 0; i--) {
            const timer = gameState.timers[i];
            const elapsed = Date.now() - timer.startTime;
            const remaining = timer.duration - elapsed;
            const timerEl = document.getElementById(`timer-${timer.id}`);
            if (remaining <= 0) {
                logEvent(`✅ 計時器完成：「${timer.name}」！`);
                if(timerEl) timerEl.remove();
                gameState.timers.splice(i, 1);
                saveState();
            } else if (timerEl) {
                timerEl.querySelector('.timer-time').textContent = formatDuration(remaining / 1000);
            }
        }
    }
    
    function renderAllTimers() {
        elements.timersArea.innerHTML = '';
        gameState.timers.forEach(timer => {
            const el = document.createElement('div');
            el.className = 'status-item timer-item';
            el.id = `timer-${timer.id}`;
            const remaining = timer.duration - (Date.now() - timer.startTime);
            el.innerHTML = `<span>${timer.icon} ${timer.name} (剩餘 <span class="timer-time">${formatDuration(remaining / 1000)}</span>)</span><span>進行中...</span>`;
            elements.timersArea.appendChild(el);
        });
    }

    const punishmentTypes = {
        'towel_punishment': { name: '涼巾懲罰', icon: '🥶' },
        'foam_punishment': { name: '刮鬍泡懲罰', icon: '☁️' },
        'dildo_punishment': { name: '深喉嚨假屌10次', icon: '🍆' },
        'russian_twist': { name: '俄羅斯轉體60次', icon: '💪' },
        'ankle_touch': { name: '仰臥摸腳踝60次', icon: '💪' },
    };

    function addPunishment(type, amount) {
        if (!punishmentTypes[type]) return;
        if (!gameState.punishments[type]) {
            gameState.punishments[type] = 0;
        }
        gameState.punishments[type] += amount;
        logEvent(`${punishmentTypes[type].icon} 新增懲罰：「${punishmentTypes[type].name}」！`);
        renderPunishments();
        saveState();
    }
    
    function renderPunishments() {
        elements.punishmentArea.innerHTML = '';
        for (const type in gameState.punishments) {
            const count = gameState.punishments[type];
            if (count > 0) {
                const config = punishmentTypes[type];
                const el = document.createElement('div');
                el.className = 'status-item punishment-item';
                el.innerHTML = `<span>${config.icon} 待執行${config.name}: ${count} 次</span><button class="btn btn-sm btn-danger">確認執行</button>`;
                el.querySelector('button').addEventListener('click', () => { 
                    gameState.punishments[type]--; 
                    logEvent(`${config.icon} 你完成了一次${config.name}！`); 
                    renderPunishments(); 
                    saveState(); 
                });
                elements.punishmentArea.appendChild(el);
            }
        }
    }

    // --- Event Listeners ---
    elements.newChallengeBtn.addEventListener('click', () => openModal('difficultyModal'));
    elements.difficultySelection.addEventListener('click', (e) => {
        if (e.target.tagName === 'BUTTON') {
            startNewChallenge(parseInt(e.target.dataset.level), parseFloat(e.target.dataset.multiplier));
        }
    });
    elements.diceBtn.addEventListener('click', rollDice);
    elements.slotBtn.addEventListener('click', pullSlotMachine);
    elements.rouletteBtn.addEventListener('click', setupRoulette);
    elements.monopolyBtn.addEventListener('click', setupMonopoly);
    elements.lottoBtn.addEventListener('click', setupLotto);
    elements.threeDoorsBtn.addEventListener('click', setupThreeDoors);
    elements.unlockBtn.addEventListener('click', attemptUnlock);
    elements.finalUnlockCloseBtn.addEventListener('click', () => {
        closeModal('finalUnlockModal');
        if (!gameState.targetTime) initializeGame();
    });
    elements.spinRouletteBtn.addEventListener('click', spinRoulette);
    document.querySelectorAll('[data-bet-type="color"]').forEach(btn => {
        btn.addEventListener('click', () => placeRouletteBet('color', btn.dataset.betValue));
    });
    elements.specificBetBtn.addEventListener('click', () => {
        const val = parseInt(document.getElementById('specificBetInput').value);
        if (!isNaN(val) && val >= 0 && val <= 11) placeRouletteBet('specific', val);
    });
    elements.monopolyRollBtn.addEventListener('click', rollMonopolyDice);
    elements.drawLottoBtn.addEventListener('click', drawLotto);
    document.getElementById('stickBtn').addEventListener('click', () => resolveThreeDoors(false));
    document.getElementById('switchBtn').addEventListener('click', () => resolveThreeDoors(true));

    // --- Initial Load ---
    window.onload = initializeGame;
    </script>
</body>
</html>
